
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
	'use strict';

	// generated during release, do not modify

	const PUBLIC_VERSION = '5';

	if (typeof window !== 'undefined') {
		// @ts-expect-error
		((window.__svelte ??= {}).v ??= new Set()).add(PUBLIC_VERSION);
	}

	let legacy_mode_flag = false;
	let tracing_mode_flag = false;

	function enable_legacy_mode_flag() {
		legacy_mode_flag = true;
	}

	enable_legacy_mode_flag();

	const EACH_ITEM_REACTIVE = 1;
	const EACH_INDEX_REACTIVE = 1 << 1;
	/** See EachBlock interface metadata.is_controlled for an explanation what this is */
	const EACH_IS_CONTROLLED = 1 << 2;
	const EACH_IS_ANIMATED = 1 << 3;
	const EACH_ITEM_IMMUTABLE = 1 << 4;

	const TEMPLATE_FRAGMENT = 1;
	const TEMPLATE_USE_IMPORT_NODE = 1 << 1;

	const UNINITIALIZED = Symbol();

	// Dev-time component properties
	const FILENAME = Symbol('filename');

	const node_env = globalThis.process?.env?.NODE_ENV;
	var DEV = node_env && !node_env.toLowerCase().startsWith('prod');

	// Store the references to globals in case someone tries to monkey patch these, causing the below
	// to de-opt (this occurs often when using popular extensions).
	var is_array = Array.isArray;
	var index_of = Array.prototype.indexOf;
	var array_from = Array.from;
	var define_property = Object.defineProperty;
	var get_descriptor = Object.getOwnPropertyDescriptor;
	var object_prototype = Object.prototype;
	var array_prototype = Array.prototype;
	var get_prototype_of = Object.getPrototypeOf;
	var is_extensible = Object.isExtensible;

	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */
	function is_function(thing) {
		return typeof thing === 'function';
	}

	/** @param {Array<() => void>} arr */
	function run_all(arr) {
		for (var i = 0; i < arr.length; i++) {
			arr[i]();
		}
	}

	const DERIVED = 1 << 1;
	const EFFECT = 1 << 2;
	const RENDER_EFFECT = 1 << 3;
	const BLOCK_EFFECT = 1 << 4;
	const BRANCH_EFFECT = 1 << 5;
	const ROOT_EFFECT = 1 << 6;
	const BOUNDARY_EFFECT = 1 << 7;
	const UNOWNED = 1 << 8;
	const DISCONNECTED = 1 << 9;
	const CLEAN = 1 << 10;
	const DIRTY = 1 << 11;
	const MAYBE_DIRTY = 1 << 12;
	const INERT = 1 << 13;
	const DESTROYED = 1 << 14;
	const EFFECT_RAN = 1 << 15;
	/** 'Transparent' effects do not create a transition boundary */
	const EFFECT_TRANSPARENT = 1 << 16;
	const INSPECT_EFFECT = 1 << 18;
	const HEAD_EFFECT = 1 << 19;
	const EFFECT_HAS_DERIVED = 1 << 20;
	const EFFECT_IS_UPDATING = 1 << 21;

	const STATE_SYMBOL = Symbol('$state');
	const LEGACY_PROPS = Symbol('legacy props');
	const PROXY_PATH_SYMBOL = Symbol('proxy path');

	/** @import { Equals } from '#client' */

	/** @type {Equals} */
	function equals$1(value) {
		return value === this.v;
	}

	/**
	 * @param {unknown} a
	 * @param {unknown} b
	 * @returns {boolean}
	 */
	function safe_not_equal(a, b) {
		return a != a
			? b == b
			: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';
	}

	/** @type {Equals} */
	function safe_equals(value) {
		return !safe_not_equal(value, this.v);
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * Calling `%method%` on a component instance (of %component%) is no longer valid in Svelte 5
	 * @param {string} method
	 * @param {string} component
	 * @returns {never}
	 */
	function component_api_changed(method, component) {
		if (DEV) {
			const error = new Error(`component_api_changed\nCalling \`${method}\` on a component instance (of ${component}) is no longer valid in Svelte 5\nhttps://svelte.dev/e/component_api_changed`);

			error.name = 'Svelte error';
			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/component_api_changed`);
		}
	}

	/**
	 * Attempted to instantiate %component% with `new %name%`, which is no longer valid in Svelte 5. If this component is not under your control, set the `compatibility.componentApi` compiler option to `4` to keep it working.
	 * @param {string} component
	 * @param {string} name
	 * @returns {never}
	 */
	function component_api_invalid_new(component, name) {
		if (DEV) {
			const error = new Error(`component_api_invalid_new\nAttempted to instantiate ${component} with \`new ${name}\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \`compatibility.componentApi\` compiler option to \`4\` to keep it working.\nhttps://svelte.dev/e/component_api_invalid_new`);

			error.name = 'Svelte error';
			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/component_api_invalid_new`);
		}
	}

	/**
	 * A derived value cannot reference itself recursively
	 * @returns {never}
	 */
	function derived_references_self() {
		if (DEV) {
			const error = new Error(`derived_references_self\nA derived value cannot reference itself recursively\nhttps://svelte.dev/e/derived_references_self`);

			error.name = 'Svelte error';
			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/derived_references_self`);
		}
	}

	/**
	 * `%rune%` cannot be used inside an effect cleanup function
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_in_teardown(rune) {
		if (DEV) {
			const error = new Error(`effect_in_teardown\n\`${rune}\` cannot be used inside an effect cleanup function\nhttps://svelte.dev/e/effect_in_teardown`);

			error.name = 'Svelte error';
			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/effect_in_teardown`);
		}
	}

	/**
	 * Effect cannot be created inside a `$derived` value that was not itself created inside an effect
	 * @returns {never}
	 */
	function effect_in_unowned_derived() {
		if (DEV) {
			const error = new Error(`effect_in_unowned_derived\nEffect cannot be created inside a \`$derived\` value that was not itself created inside an effect\nhttps://svelte.dev/e/effect_in_unowned_derived`);

			error.name = 'Svelte error';
			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
		}
	}

	/**
	 * `%rune%` can only be used inside an effect (e.g. during component initialisation)
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_orphan(rune) {
		if (DEV) {
			const error = new Error(`effect_orphan\n\`${rune}\` can only be used inside an effect (e.g. during component initialisation)\nhttps://svelte.dev/e/effect_orphan`);

			error.name = 'Svelte error';
			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/effect_orphan`);
		}
	}

	/**
	 * Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops
	 * @returns {never}
	 */
	function effect_update_depth_exceeded() {
		if (DEV) {
			const error = new Error(`effect_update_depth_exceeded\nMaximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops\nhttps://svelte.dev/e/effect_update_depth_exceeded`);

			error.name = 'Svelte error';
			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
		}
	}

	/**
	 * The `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files
	 * @param {string} rune
	 * @returns {never}
	 */
	function rune_outside_svelte(rune) {
		if (DEV) {
			const error = new Error(`rune_outside_svelte\nThe \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files\nhttps://svelte.dev/e/rune_outside_svelte`);

			error.name = 'Svelte error';
			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
		}
	}

	/**
	 * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.
	 * @returns {never}
	 */
	function state_descriptors_fixed() {
		if (DEV) {
			const error = new Error(`state_descriptors_fixed\nProperty descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.\nhttps://svelte.dev/e/state_descriptors_fixed`);

			error.name = 'Svelte error';
			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
		}
	}

	/**
	 * Cannot set prototype of `$state` object
	 * @returns {never}
	 */
	function state_prototype_fixed() {
		if (DEV) {
			const error = new Error(`state_prototype_fixed\nCannot set prototype of \`$state\` object\nhttps://svelte.dev/e/state_prototype_fixed`);

			error.name = 'Svelte error';
			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
		}
	}

	/**
	 * Updating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without `$state`
	 * @returns {never}
	 */
	function state_unsafe_mutation() {
		if (DEV) {
			const error = new Error(`state_unsafe_mutation\nUpdating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`\nhttps://svelte.dev/e/state_unsafe_mutation`);

			error.name = 'Svelte error';
			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	var bold$1 = 'font-weight: bold';
	var normal$1 = 'font-weight: normal';

	/**
	 * The following properties cannot be cloned with `$state.snapshot` — the return value contains the originals:
	 * 
	 * %properties%
	 * @param {string | undefined | null} [properties]
	 */
	function state_snapshot_uncloneable(properties) {
		if (DEV) {
			console.warn(`%c[svelte] state_snapshot_uncloneable\n%c${properties
			? `The following properties cannot be cloned with \`$state.snapshot\` — the return value contains the originals:

${properties}`
			: 'Value cannot be cloned with `$state.snapshot` — the original value was returned'}\nhttps://svelte.dev/e/state_snapshot_uncloneable`, bold$1, normal$1);
		} else {
			console.warn(`https://svelte.dev/e/state_snapshot_uncloneable`);
		}
	}

	/** @import { Snapshot } from './types' */

	/**
	 * In dev, we keep track of which properties could not be cloned. In prod
	 * we don't bother, but we keep a dummy array around so that the
	 * signature stays the same
	 * @type {string[]}
	 */
	const empty$1 = [];

	/**
	 * @template T
	 * @param {T} value
	 * @param {boolean} [skip_warning]
	 * @returns {Snapshot<T>}
	 */
	function snapshot(value, skip_warning = false) {
		if (DEV && !skip_warning) {
			/** @type {string[]} */
			const paths = [];

			const copy = clone(value, new Map(), '', paths);
			if (paths.length === 1 && paths[0] === '') {
				// value could not be cloned
				state_snapshot_uncloneable();
			} else if (paths.length > 0) {
				// some properties could not be cloned
				const slice = paths.length > 10 ? paths.slice(0, 7) : paths.slice(0, 10);
				const excess = paths.length - slice.length;

				let uncloned = slice.map((path) => `- <value>${path}`).join('\n');
				if (excess > 0) uncloned += `\n- ...and ${excess} more`;

				state_snapshot_uncloneable(uncloned);
			}

			return copy;
		}

		return clone(value, new Map(), '', empty$1);
	}

	/**
	 * @template T
	 * @param {T} value
	 * @param {Map<T, Snapshot<T>>} cloned
	 * @param {string} path
	 * @param {string[]} paths
	 * @param {null | T} original The original value, if `value` was produced from a `toJSON` call
	 * @returns {Snapshot<T>}
	 */
	function clone(value, cloned, path, paths, original = null) {
		if (typeof value === 'object' && value !== null) {
			var unwrapped = cloned.get(value);
			if (unwrapped !== undefined) return unwrapped;

			if (value instanceof Map) return /** @type {Snapshot<T>} */ (new Map(value));
			if (value instanceof Set) return /** @type {Snapshot<T>} */ (new Set(value));

			if (is_array(value)) {
				var copy = /** @type {Snapshot<any>} */ (Array(value.length));
				cloned.set(value, copy);

				if (original !== null) {
					cloned.set(original, copy);
				}

				for (var i = 0; i < value.length; i += 1) {
					var element = value[i];
					if (i in value) {
						copy[i] = clone(element, cloned, DEV ? `${path}[${i}]` : path, paths);
					}
				}

				return copy;
			}

			if (get_prototype_of(value) === object_prototype) {
				/** @type {Snapshot<any>} */
				copy = {};
				cloned.set(value, copy);

				if (original !== null) {
					cloned.set(original, copy);
				}

				for (var key in value) {
					// @ts-expect-error
					copy[key] = clone(value[key], cloned, DEV ? `${path}.${key}` : path, paths);
				}

				return copy;
			}

			if (value instanceof Date) {
				return /** @type {Snapshot<T>} */ (structuredClone(value));
			}

			if (typeof (/** @type {T & { toJSON?: any } } */ (value).toJSON) === 'function') {
				return clone(
					/** @type {T & { toJSON(): any } } */ (value).toJSON(),
					cloned,
					DEV ? `${path}.toJSON()` : path,
					paths,
					// Associate the instance with the toJSON clone
					value
				);
			}
		}

		if (value instanceof EventTarget) {
			// can't be cloned
			return /** @type {Snapshot<T>} */ (value);
		}

		try {
			return /** @type {Snapshot<T>} */ (structuredClone(value));
		} catch (e) {
			if (DEV) {
				paths.push(path);
			}

			return /** @type {Snapshot<T>} */ (value);
		}
	}

	/** @import { Derived, Reaction, Value } from '#client' */

	/**
	 * @typedef {{
	 *   traces: Error[];
	 * }} TraceEntry
	 */

	/** @type {{ reaction: Reaction | null, entries: Map<Value, TraceEntry> } | null} */
	let tracing_expressions = null;

	/**
	 * @param {string} label
	 */
	function get_stack(label) {
		let error = Error();
		const stack = error.stack;

		if (stack) {
			const lines = stack.split('\n');
			const new_lines = ['\n'];

			for (let i = 0; i < lines.length; i++) {
				const line = lines[i];

				if (line === 'Error') {
					continue;
				}
				if (line.includes('validate_each_keys')) {
					return null;
				}
				if (line.includes('svelte/src/internal')) {
					continue;
				}
				new_lines.push(line);
			}

			if (new_lines.length === 1) {
				return null;
			}

			define_property(error, 'stack', {
				value: new_lines.join('\n')
			});

			define_property(error, 'name', {
				// 'Error' suffix is required for stack traces to be rendered properly
				value: `${label}Error`
			});
		}
		return error;
	}

	/**
	 * @param {Value} source
	 * @param {string} label
	 */
	function tag(source, label) {
		source.label = label;
		tag_proxy(source.v, label);

		return source;
	}

	/**
	 * @param {unknown} value
	 * @param {string} label
	 */
	function tag_proxy(value, label) {
		// @ts-expect-error
		value?.[PROXY_PATH_SYMBOL]?.(label);
		return value;
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * `%name%(...)` can only be used during component initialisation
	 * @param {string} name
	 * @returns {never}
	 */
	function lifecycle_outside_component(name) {
		if (DEV) {
			const error = new Error(`lifecycle_outside_component\n\`${name}(...)\` can only be used during component initialisation\nhttps://svelte.dev/e/lifecycle_outside_component`);

			error.name = 'Svelte error';
			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
		}
	}

	/** @import { ComponentContext } from '#client' */


	/** @type {ComponentContext | null} */
	let component_context = null;

	/** @param {ComponentContext | null} context */
	function set_component_context(context) {
		component_context = context;
	}

	/**
	 * The current component function. Different from current component context:
	 * ```html
	 * <!-- App.svelte -->
	 * <Foo>
	 *   <Bar /> <!-- context == Foo.svelte, function == App.svelte -->
	 * </Foo>
	 * ```
	 * @type {ComponentContext['function']}
	 */
	let dev_current_component_function = null;

	/** @param {ComponentContext['function']} fn */
	function set_dev_current_component_function(fn) {
		dev_current_component_function = fn;
	}

	/**
	 * @param {Record<string, unknown>} props
	 * @param {any} runes
	 * @param {Function} [fn]
	 * @returns {void}
	 */
	function push(props, runes = false, fn) {
		var ctx = (component_context = {
			p: component_context,
			c: null,
			d: false,
			e: null,
			m: false,
			s: props,
			x: null,
			l: null
		});

		if (legacy_mode_flag && !runes) {
			component_context.l = {
				s: null,
				u: null,
				r1: [],
				r2: source(false)
			};
		}

		teardown(() => {
			/** @type {ComponentContext} */ (ctx).d = true;
		});

		if (DEV) {
			// component function
			component_context.function = fn;
			dev_current_component_function = fn;
		}
	}

	/**
	 * @template {Record<string, any>} T
	 * @param {T} [component]
	 * @returns {T}
	 */
	function pop(component) {
		const context_stack_item = component_context;
		if (context_stack_item !== null) {
			if (component !== undefined) {
				context_stack_item.x = component;
			}
			const component_effects = context_stack_item.e;
			if (component_effects !== null) {
				var previous_effect = active_effect;
				var previous_reaction = active_reaction;
				context_stack_item.e = null;
				try {
					for (var i = 0; i < component_effects.length; i++) {
						var component_effect = component_effects[i];
						set_active_effect(component_effect.effect);
						set_active_reaction(component_effect.reaction);
						effect(component_effect.fn);
					}
				} finally {
					set_active_effect(previous_effect);
					set_active_reaction(previous_reaction);
				}
			}
			component_context = context_stack_item.p;
			if (DEV) {
				dev_current_component_function = context_stack_item.p?.function ?? null;
			}
			context_stack_item.m = true;
		}
		// Micro-optimization: Don't set .a above to the empty object
		// so it can be garbage-collected when the return here is unused
		return component || /** @type {T} */ ({});
	}

	/** @returns {boolean} */
	function is_runes() {
		return !legacy_mode_flag || (component_context !== null && component_context.l === null);
	}

	/** @import { Source } from '#client' */

	// TODO move all regexes into shared module?
	const regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;

	/**
	 * @template T
	 * @param {T} value
	 * @returns {T}
	 */
	function proxy(value) {
		// if non-proxyable, or is already a proxy, return `value`
		if (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {
			return value;
		}

		const prototype = get_prototype_of(value);

		if (prototype !== object_prototype && prototype !== array_prototype) {
			return value;
		}

		/** @type {Map<any, Source<any>>} */
		var sources = new Map();
		var is_proxied_array = is_array(value);
		var version = state(0);

		var stack = DEV && tracing_mode_flag ? get_stack('CreatedAt') : null;
		var reaction = active_reaction;

		/**
		 * Executes the proxy in the context of the reaction it was originally created in, if any
		 * @template T
		 * @param {() => T} fn
		 */
		var with_parent = (fn) => {
			var previous_reaction = active_reaction;
			set_active_reaction(reaction);

			/** @type {T} */
			var result = fn();

			set_active_reaction(previous_reaction);
			return result;
		};

		if (is_proxied_array) {
			// We need to create the length source eagerly to ensure that
			// mutations to the array are properly synced with our proxy
			sources.set('length', state(/** @type {any[]} */ (value).length, stack));
		}

		/** Used in dev for $inspect.trace() */
		var path = '';

		/** @param {string} new_path */
		function update_path(new_path) {
			path = new_path;

			tag(version, `${path} version`);

			// rename all child sources and child proxies
			for (const [prop, source] of sources) {
				tag(source, get_label(path, prop));
			}
		}

		return new Proxy(/** @type {any} */ (value), {
			defineProperty(_, prop, descriptor) {
				if (
					!('value' in descriptor) ||
					descriptor.configurable === false ||
					descriptor.enumerable === false ||
					descriptor.writable === false
				) {
					// we disallow non-basic descriptors, because unless they are applied to the
					// target object — which we avoid, so that state can be forked — we will run
					// afoul of the various invariants
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants
					state_descriptors_fixed();
				}
				var s = sources.get(prop);
				if (s === undefined) {
					s = with_parent(() => {
						var s = state(descriptor.value, stack);
						sources.set(prop, s);
						if (DEV && typeof prop === 'string') {
							tag(s, get_label(path, prop));
						}
						return s;
					});
				} else {
					set(s, descriptor.value, true);
				}

				return true;
			},

			deleteProperty(target, prop) {
				var s = sources.get(prop);

				if (s === undefined) {
					if (prop in target) {
						const s = with_parent(() => state(UNINITIALIZED, stack));
						sources.set(prop, s);
						update_version(version);

						if (DEV) {
							tag(s, get_label(path, prop));
						}
					}
				} else {
					// When working with arrays, we need to also ensure we update the length when removing
					// an indexed property
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n < ls.v) {
							set(ls, n);
						}
					}
					set(s, UNINITIALIZED);
					update_version(version);
				}

				return true;
			},

			get(target, prop, receiver) {
				if (prop === STATE_SYMBOL) {
					return value;
				}

				if (DEV && prop === PROXY_PATH_SYMBOL) {
					return update_path;
				}

				var s = sources.get(prop);
				var exists = prop in target;

				// create a source, but only if it's an own property and not a prototype property
				if (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {
					s = with_parent(() => {
						var p = proxy(exists ? target[prop] : UNINITIALIZED);
						var s = state(p, stack);

						if (DEV) {
							tag(s, get_label(path, prop));
						}

						return s;
					});

					sources.set(prop, s);
				}

				if (s !== undefined) {
					var v = get(s);
					return v === UNINITIALIZED ? undefined : v;
				}

				return Reflect.get(target, prop, receiver);
			},

			getOwnPropertyDescriptor(target, prop) {
				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				if (descriptor && 'value' in descriptor) {
					var s = sources.get(prop);
					if (s) descriptor.value = get(s);
				} else if (descriptor === undefined) {
					var source = sources.get(prop);
					var value = source?.v;

					if (source !== undefined && value !== UNINITIALIZED) {
						return {
							enumerable: true,
							configurable: true,
							value,
							writable: true
						};
					}
				}

				return descriptor;
			},

			has(target, prop) {
				if (prop === STATE_SYMBOL) {
					return true;
				}

				var s = sources.get(prop);
				var has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);

				if (
					s !== undefined ||
					(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))
				) {
					if (s === undefined) {
						s = with_parent(() => {
							var p = has ? proxy(target[prop]) : UNINITIALIZED;
							var s = state(p, stack);

							if (DEV) {
								tag(s, get_label(path, prop));
							}

							return s;
						});

						sources.set(prop, s);
					}

					var value = get(s);
					if (value === UNINITIALIZED) {
						return false;
					}
				}

				return has;
			},

			set(target, prop, value, receiver) {
				var s = sources.get(prop);
				var has = prop in target;

				// variable.length = value -> clear all signals with index >= value
				if (is_proxied_array && prop === 'length') {
					for (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {
						var other_s = sources.get(i + '');
						if (other_s !== undefined) {
							set(other_s, UNINITIALIZED);
						} else if (i in target) {
							// If the item exists in the original, we need to create a uninitialized source,
							// else a later read of the property would result in a source being created with
							// the value of the original item at that index.
							other_s = with_parent(() => state(UNINITIALIZED, stack));
							sources.set(i + '', other_s);

							if (DEV) {
								tag(other_s, get_label(path, i));
							}
						}
					}
				}

				// If we haven't yet created a source for this property, we need to ensure
				// we do so otherwise if we read it later, then the write won't be tracked and
				// the heuristics of effects will be different vs if we had read the proxied
				// object property before writing to that property.
				if (s === undefined) {
					if (!has || get_descriptor(target, prop)?.writable) {
						s = with_parent(() => state(undefined, stack));
						set(s, proxy(value));

						sources.set(prop, s);

						if (DEV) {
							tag(s, get_label(path, prop));
						}
					}
				} else {
					has = s.v !== UNINITIALIZED;

					var p = with_parent(() => proxy(value));
					set(s, p);
				}

				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				// Set the new value before updating any signals so that any listeners get the new value
				if (descriptor?.set) {
					descriptor.set.call(receiver, value);
				}

				if (!has) {
					// If we have mutated an array directly, we might need to
					// signal that length has also changed. Do it before updating metadata
					// to ensure that iterating over the array as a result of a metadata update
					// will not cause the length to be out of sync.
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n >= ls.v) {
							set(ls, n + 1);
						}
					}

					update_version(version);
				}

				return true;
			},

			ownKeys(target) {
				get(version);

				var own_keys = Reflect.ownKeys(target).filter((key) => {
					var source = sources.get(key);
					return source === undefined || source.v !== UNINITIALIZED;
				});

				for (var [key, source] of sources) {
					if (source.v !== UNINITIALIZED && !(key in target)) {
						own_keys.push(key);
					}
				}

				return own_keys;
			},

			setPrototypeOf() {
				state_prototype_fixed();
			}
		});
	}

	/**
	 * @param {string} path
	 * @param {string | symbol} prop
	 */
	function get_label(path, prop) {
		if (typeof prop === 'symbol') return `${path}[Symbol(${prop.description ?? ''})]`;
		if (regex_is_valid_identifier.test(prop)) return `${path}.${prop}`;
		return /^\d+$/.test(prop) ? `${path}[${prop}]` : `${path}['${prop}']`;
	}

	/**
	 * @param {Source<number>} signal
	 * @param {1 | -1} [d]
	 */
	function update_version(signal, d = 1) {
		set(signal, signal.v + d);
	}

	/**
	 * @param {any} value
	 */
	function get_proxied_value(value) {
		try {
			if (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {
				return value[STATE_SYMBOL];
			}
		} catch {
			// the above if check can throw an error if the value in question
			// is the contentWindow of an iframe on another domain, in which
			// case we want to just return the value (because it's definitely
			// not a proxied value) so we don't break any JavaScript interacting
			// with that iframe (such as various payment companies client side
			// JavaScript libraries interacting with their iframes on the same
			// domain)
		}

		return value;
	}

	/** @import { Derived, Effect } from '#client' */

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived(fn) {
		var flags = DERIVED | DIRTY;
		var parent_derived =
			active_reaction !== null && (active_reaction.f & DERIVED) !== 0
				? /** @type {Derived} */ (active_reaction)
				: null;

		if (active_effect === null || (parent_derived !== null && (parent_derived.f & UNOWNED) !== 0)) {
			flags |= UNOWNED;
		} else {
			// Since deriveds are evaluated lazily, any effects created inside them are
			// created too late to ensure that the parent effect is added to the tree
			active_effect.f |= EFFECT_HAS_DERIVED;
		}

		/** @type {Derived<V>} */
		const signal = {
			ctx: component_context,
			deps: null,
			effects: null,
			equals: equals$1,
			f: flags,
			fn,
			reactions: null,
			rv: 0,
			v: /** @type {V} */ (null),
			wv: 0,
			parent: parent_derived ?? active_effect
		};

		if (DEV && tracing_mode_flag) {
			signal.created = get_stack('CreatedAt');
		}

		return signal;
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function user_derived(fn) {
		const d = derived(fn);

		push_reaction_value(d);

		return d;
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived_safe_equal(fn) {
		const signal = derived(fn);
		signal.equals = safe_equals;
		return signal;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function destroy_derived_effects(derived) {
		var effects = derived.effects;

		if (effects !== null) {
			derived.effects = null;

			for (var i = 0; i < effects.length; i += 1) {
				destroy_effect(/** @type {Effect} */ (effects[i]));
			}
		}
	}

	/**
	 * The currently updating deriveds, used to detect infinite recursion
	 * in dev mode and provide a nicer error than 'too much recursion'
	 * @type {Derived[]}
	 */
	let stack = [];

	/**
	 * @param {Derived} derived
	 * @returns {Effect | null}
	 */
	function get_derived_parent_effect(derived) {
		var parent = derived.parent;
		while (parent !== null) {
			if ((parent.f & DERIVED) === 0) {
				return /** @type {Effect} */ (parent);
			}
			parent = parent.parent;
		}
		return null;
	}

	/**
	 * @template T
	 * @param {Derived} derived
	 * @returns {T}
	 */
	function execute_derived(derived) {
		var value;
		var prev_active_effect = active_effect;

		set_active_effect(get_derived_parent_effect(derived));

		if (DEV) {
			let prev_inspect_effects = inspect_effects;
			set_inspect_effects(new Set());
			try {
				if (stack.includes(derived)) {
					derived_references_self();
				}

				stack.push(derived);

				destroy_derived_effects(derived);
				value = update_reaction(derived);
			} finally {
				set_active_effect(prev_active_effect);
				set_inspect_effects(prev_inspect_effects);
				stack.pop();
			}
		} else {
			try {
				destroy_derived_effects(derived);
				value = update_reaction(derived);
			} finally {
				set_active_effect(prev_active_effect);
			}
		}

		return value;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function update_derived(derived) {
		var value = execute_derived(derived);

		if (!derived.equals(value)) {
			derived.v = value;
			derived.wv = increment_write_version();
		}

		// don't mark derived clean if we're reading it inside a
		// cleanup function, or it will cache a stale value
		if (is_destroying_effect) return;

		var status =
			(skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;

		set_signal_status(derived, status);
	}

	/** @import { Derived, Effect, Source, Value } from '#client' */

	let inspect_effects = new Set();

	/** @type {Map<Source, any>} */
	const old_values = new Map();

	/**
	 * @param {Set<any>} v
	 */
	function set_inspect_effects(v) {
		inspect_effects = v;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 * @returns {Source<V>}
	 */
	// TODO rename this to `state` throughout the codebase
	function source(v, stack) {
		/** @type {Value} */
		var signal = {
			f: 0, // TODO ideally we could skip this altogether, but it causes type errors
			v,
			reactions: null,
			equals: equals$1,
			rv: 0,
			wv: 0
		};

		if (DEV && tracing_mode_flag) {
			signal.created = stack ?? get_stack('CreatedAt');
			signal.updated = null;
			signal.set_during_effect = false;
			signal.trace = null;
		}

		return signal;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function state(v, stack) {
		const s = source(v, stack);

		push_reaction_value(s);

		return s;
	}

	/**
	 * @template V
	 * @param {V} initial_value
	 * @param {boolean} [immutable]
	 * @returns {Source<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function mutable_source(initial_value, immutable = false, trackable = true) {
		const s = source(initial_value);
		if (!immutable) {
			s.equals = safe_equals;
		}

		// bind the signal to the component context, in case we need to
		// track updates to trigger beforeUpdate/afterUpdate callbacks
		if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) {
			(component_context.l.s ??= []).push(s);
		}

		return s;
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @param {boolean} [should_proxy]
	 * @returns {V}
	 */
	function set(source, value, should_proxy = false) {
		if (
			active_reaction !== null &&
			!untracking &&
			is_runes() &&
			(active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 &&
			!(reaction_sources?.[1].includes(source) && reaction_sources[0] === active_reaction)
		) {
			state_unsafe_mutation();
		}

		let new_value = should_proxy ? proxy(value) : value;

		if (DEV) {
			tag_proxy(new_value, /** @type {string} */ (source.label));
		}

		return internal_set(source, new_value);
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @returns {V}
	 */
	function internal_set(source, value) {
		if (!source.equals(value)) {
			var old_value = source.v;

			if (is_destroying_effect) {
				old_values.set(source, value);
			} else {
				old_values.set(source, old_value);
			}

			source.v = value;

			if (DEV && tracing_mode_flag) {
				source.updated = get_stack('UpdatedAt');

				if (active_effect !== null) {
					source.set_during_effect = true;
				}
			}

			if ((source.f & DERIVED) !== 0) {
				// if we are assigning to a dirty derived we set it to clean/maybe dirty but we also eagerly execute it to track the dependencies
				if ((source.f & DIRTY) !== 0) {
					execute_derived(/** @type {Derived} */ (source));
				}
				set_signal_status(source, (source.f & UNOWNED) === 0 ? CLEAN : MAYBE_DIRTY);
			}

			source.wv = increment_write_version();

			mark_reactions(source, DIRTY);

			// It's possible that the current reaction might not have up-to-date dependencies
			// whilst it's actively running. So in the case of ensuring it registers the reaction
			// properly for itself, we need to ensure the current effect actually gets
			// scheduled. i.e: `$effect(() => x++)`
			if (
				is_runes() &&
				active_effect !== null &&
				(active_effect.f & CLEAN) !== 0 &&
				(active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0
			) {
				if (untracked_writes === null) {
					set_untracked_writes([source]);
				} else {
					untracked_writes.push(source);
				}
			}

			if (DEV && inspect_effects.size > 0) {
				const inspects = Array.from(inspect_effects);

				for (const effect of inspects) {
					// Mark clean inspect-effects as maybe dirty and then check their dirtiness
					// instead of just updating the effects - this way we avoid overfiring.
					if ((effect.f & CLEAN) !== 0) {
						set_signal_status(effect, MAYBE_DIRTY);
					}
					if (check_dirtiness(effect)) {
						update_effect(effect);
					}
				}

				inspect_effects.clear();
			}
		}

		return value;
	}

	/**
	 * @param {Value} signal
	 * @param {number} status should be DIRTY or MAYBE_DIRTY
	 * @returns {void}
	 */
	function mark_reactions(signal, status) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		var runes = is_runes();
		var length = reactions.length;

		for (var i = 0; i < length; i++) {
			var reaction = reactions[i];
			var flags = reaction.f;

			// Skip any effects that are already dirty
			if ((flags & DIRTY) !== 0) continue;

			// In legacy mode, skip the current effect to prevent infinite loops
			if (!runes && reaction === active_effect) continue;

			// Inspect effects need to run immediately, so that the stack trace makes sense
			if (DEV && (flags & INSPECT_EFFECT) !== 0) {
				inspect_effects.add(reaction);
				continue;
			}

			set_signal_status(reaction, status);

			// If the signal a) was previously clean or b) is an unowned derived, then mark it
			if ((flags & (CLEAN | UNOWNED)) !== 0) {
				if ((flags & DERIVED) !== 0) {
					mark_reactions(/** @type {Derived} */ (reaction), MAYBE_DIRTY);
				} else {
					schedule_effect(/** @type {Effect} */ (reaction));
				}
			}
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	var bold = 'font-weight: bold';
	var normal = 'font-weight: normal';

	/**
	 * Your `console.%method%` contained `$state` proxies. Consider using `$inspect(...)` or `$state.snapshot(...)` instead
	 * @param {string} method
	 */
	function console_log_state(method) {
		if (DEV) {
			console.warn(`%c[svelte] console_log_state\n%cYour \`console.${method}\` contained \`$state\` proxies. Consider using \`$inspect(...)\` or \`$state.snapshot(...)\` instead\nhttps://svelte.dev/e/console_log_state`, bold, normal);
		} else {
			console.warn(`https://svelte.dev/e/console_log_state`);
		}
	}

	/**
	 * Detected a migrated `$:` reactive block in `%filename%` that both accesses and updates the same reactive value. This may cause recursive updates when converted to an `$effect`.
	 * @param {string} filename
	 */
	function legacy_recursive_reactive_block(filename) {
		if (DEV) {
			console.warn(`%c[svelte] legacy_recursive_reactive_block\n%cDetected a migrated \`$:\` reactive block in \`${filename}\` that both accesses and updates the same reactive value. This may cause recursive updates when converted to an \`$effect\`.\nhttps://svelte.dev/e/legacy_recursive_reactive_block`, bold, normal);
		} else {
			console.warn(`https://svelte.dev/e/legacy_recursive_reactive_block`);
		}
	}

	/**
	 * Reactive `$state(...)` proxies and the values they proxy have different identities. Because of this, comparisons with `%operator%` will produce unexpected results
	 * @param {string} operator
	 */
	function state_proxy_equality_mismatch(operator) {
		if (DEV) {
			console.warn(`%c[svelte] state_proxy_equality_mismatch\n%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results\nhttps://svelte.dev/e/state_proxy_equality_mismatch`, bold, normal);
		} else {
			console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
		}
	}

	/** @import { TemplateNode } from '#client' */


	/**
	 * Use this variable to guard everything related to hydration code so it can be treeshaken out
	 * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.
	 */
	let hydrating = false;

	function init_array_prototype_warnings() {
		const array_prototype = Array.prototype;
		// The REPL ends up here over and over, and this prevents it from adding more and more patches
		// of the same kind to the prototype, which would slow down everything over time.
		// @ts-expect-error
		const cleanup = Array.__svelte_cleanup;
		if (cleanup) {
			cleanup();
		}

		const { indexOf, lastIndexOf, includes } = array_prototype;

		array_prototype.indexOf = function (item, from_index) {
			const index = indexOf.call(this, item, from_index);

			if (index === -1) {
				for (let i = from_index ?? 0; i < this.length; i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.indexOf(...)');
						break;
					}
				}
			}

			return index;
		};

		array_prototype.lastIndexOf = function (item, from_index) {
			// we need to specify this.length - 1 because it's probably using something like
			// `arguments` inside so passing undefined is different from not passing anything
			const index = lastIndexOf.call(this, item, from_index ?? this.length - 1);

			if (index === -1) {
				for (let i = 0; i <= (from_index ?? this.length - 1); i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.lastIndexOf(...)');
						break;
					}
				}
			}

			return index;
		};

		array_prototype.includes = function (item, from_index) {
			const has = includes.call(this, item, from_index);

			if (!has) {
				for (let i = 0; i < this.length; i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.includes(...)');
						break;
					}
				}
			}

			return has;
		};

		// @ts-expect-error
		Array.__svelte_cleanup = () => {
			array_prototype.indexOf = indexOf;
			array_prototype.lastIndexOf = lastIndexOf;
			array_prototype.includes = includes;
		};
	}

	/**
	 * @param {any} a
	 * @param {any} b
	 * @param {boolean} equal
	 * @returns {boolean}
	 */
	function strict_equals(a, b, equal = true) {
		// try-catch needed because this tries to read properties of `a` and `b`,
		// which could be disallowed for example in a secure context
		try {
			if ((a === b) !== (get_proxied_value(a) === get_proxied_value(b))) {
				state_proxy_equality_mismatch(equal ? '===' : '!==');
			}
		} catch {}

		return (a === b) === equal;
	}

	/**
	 * @param {any} a
	 * @param {any} b
	 * @param {boolean} equal
	 * @returns {boolean}
	 */
	function equals(a, b, equal = true) {
		if ((a == b) !== (get_proxied_value(a) == get_proxied_value(b))) {
			state_proxy_equality_mismatch(equal ? '==' : '!=');
		}

		return (a == b) === equal;
	}

	/** @import { TemplateNode } from '#client' */

	// export these for reference in the compiled code, making global name deduplication unnecessary
	/** @type {Window} */
	var $window;

	/** @type {boolean} */
	var is_firefox;

	/** @type {() => Node | null} */
	var first_child_getter;
	/** @type {() => Node | null} */
	var next_sibling_getter;

	/**
	 * Initialize these lazily to avoid issues when using the runtime in a server context
	 * where these globals are not available while avoiding a separate server entry point
	 */
	function init_operations() {
		if ($window !== undefined) {
			return;
		}

		$window = window;
		is_firefox = /Firefox/.test(navigator.userAgent);

		var element_prototype = Element.prototype;
		var node_prototype = Node.prototype;
		var text_prototype = Text.prototype;

		// @ts-ignore
		first_child_getter = get_descriptor(node_prototype, 'firstChild').get;
		// @ts-ignore
		next_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;

		if (is_extensible(element_prototype)) {
			// the following assignments improve perf of lookups on DOM nodes
			// @ts-expect-error
			element_prototype.__click = undefined;
			// @ts-expect-error
			element_prototype.__className = undefined;
			// @ts-expect-error
			element_prototype.__attributes = null;
			// @ts-expect-error
			element_prototype.__style = undefined;
			// @ts-expect-error
			element_prototype.__e = undefined;
		}

		if (is_extensible(text_prototype)) {
			// @ts-expect-error
			text_prototype.__t = undefined;
		}

		if (DEV) {
			// @ts-expect-error
			element_prototype.__svelte_meta = null;

			init_array_prototype_warnings();
		}
	}

	/**
	 * @param {string} value
	 * @returns {Text}
	 */
	function create_text(value = '') {
		return document.createTextNode(value);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_first_child(node) {
		return first_child_getter.call(node);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_next_sibling(node) {
		return next_sibling_getter.call(node);
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @template {Node} N
	 * @param {N} node
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function child(node, is_text) {
		{
			return get_first_child(node);
		}
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {DocumentFragment | TemplateNode[]} fragment
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function first_child(fragment, is_text) {
		{
			// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)
			var first = /** @type {DocumentFragment} */ (get_first_child(/** @type {Node} */ (fragment)));

			// TODO prevent user comments with the empty string when preserveComments is true
			if (first instanceof Comment && first.data === '') return get_next_sibling(first);

			return first;
		}
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {TemplateNode} node
	 * @param {number} count
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function sibling(node, count = 1, is_text = false) {
		let next_sibling = node;

		while (count--) {
			next_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));
		}

		{
			return next_sibling;
		}
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {void}
	 */
	function clear_text_content(node) {
		node.textContent = '';
	}

	/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, TemplateNode, TransitionManager } from '#client' */

	/**
	 * @param {'$effect' | '$effect.pre' | '$inspect'} rune
	 */
	function validate_effect(rune) {
		if (active_effect === null && active_reaction === null) {
			effect_orphan(rune);
		}

		if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0 && active_effect === null) {
			effect_in_unowned_derived();
		}

		if (is_destroying_effect) {
			effect_in_teardown(rune);
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {Effect} parent_effect
	 */
	function push_effect(effect, parent_effect) {
		var parent_last = parent_effect.last;
		if (parent_last === null) {
			parent_effect.last = parent_effect.first = effect;
		} else {
			parent_last.next = effect;
			effect.prev = parent_last;
			parent_effect.last = effect;
		}
	}

	/**
	 * @param {number} type
	 * @param {null | (() => void | (() => void))} fn
	 * @param {boolean} sync
	 * @param {boolean} push
	 * @returns {Effect}
	 */
	function create_effect(type, fn, sync, push = true) {
		var parent = active_effect;

		if (DEV) {
			// Ensure the parent is never an inspect effect
			while (parent !== null && (parent.f & INSPECT_EFFECT) !== 0) {
				parent = parent.parent;
			}
		}

		/** @type {Effect} */
		var effect = {
			ctx: component_context,
			deps: null,
			nodes_start: null,
			nodes_end: null,
			f: type | DIRTY,
			first: null,
			fn,
			last: null,
			next: null,
			parent,
			prev: null,
			teardown: null,
			transitions: null,
			wv: 0
		};

		if (DEV) {
			effect.component_function = dev_current_component_function;
		}

		if (sync) {
			try {
				update_effect(effect);
				effect.f |= EFFECT_RAN;
			} catch (e) {
				destroy_effect(effect);
				throw e;
			}
		} else if (fn !== null) {
			schedule_effect(effect);
		}

		// if an effect has no dependencies, no DOM and no teardown function,
		// don't bother adding it to the effect tree
		var inert =
			sync &&
			effect.deps === null &&
			effect.first === null &&
			effect.nodes_start === null &&
			effect.teardown === null &&
			(effect.f & (EFFECT_HAS_DERIVED | BOUNDARY_EFFECT)) === 0;

		if (!inert && push) {
			if (parent !== null) {
				push_effect(effect, parent);
			}

			// if we're in a derived, add the effect there too
			if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
				var derived = /** @type {Derived} */ (active_reaction);
				(derived.effects ??= []).push(effect);
			}
		}

		return effect;
	}

	/**
	 * @param {() => void} fn
	 */
	function teardown(fn) {
		const effect = create_effect(RENDER_EFFECT, null, false);
		set_signal_status(effect, CLEAN);
		effect.teardown = fn;
		return effect;
	}

	/**
	 * Internal representation of `$effect(...)`
	 * @param {() => void | (() => void)} fn
	 */
	function user_effect(fn) {
		validate_effect('$effect');

		// Non-nested `$effect(...)` in a component should be deferred
		// until the component is mounted
		var defer =
			active_effect !== null &&
			(active_effect.f & BRANCH_EFFECT) !== 0 &&
			component_context !== null &&
			!component_context.m;

		if (DEV) {
			define_property(fn, 'name', {
				value: '$effect'
			});
		}

		if (defer) {
			var context = /** @type {ComponentContext} */ (component_context);
			(context.e ??= []).push({
				fn,
				effect: active_effect,
				reaction: active_reaction
			});
		} else {
			var signal = effect(fn);
			return signal;
		}
	}

	/**
	 * Internal representation of `$effect.pre(...)`
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function user_pre_effect(fn) {
		validate_effect('$effect.pre');
		if (DEV) {
			define_property(fn, 'name', {
				value: '$effect.pre'
			});
		}
		return render_effect(fn);
	}

	/**
	 * An effect root whose children can transition out
	 * @param {() => void} fn
	 * @returns {(options?: { outro?: boolean }) => Promise<void>}
	 */
	function component_root(fn) {
		const effect = create_effect(ROOT_EFFECT, fn, true);

		return (options = {}) => {
			return new Promise((fulfil) => {
				if (options.outro) {
					pause_effect(effect, () => {
						destroy_effect(effect);
						fulfil(undefined);
					});
				} else {
					destroy_effect(effect);
					fulfil(undefined);
				}
			});
		};
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function effect(fn) {
		return create_effect(EFFECT, fn, false);
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function render_effect(fn) {
		return create_effect(RENDER_EFFECT, fn, true);
	}

	/**
	 * @param {(...expressions: any) => void | (() => void)} fn
	 * @param {Array<() => any>} thunks
	 * @param {<T>(fn: () => T) => Derived<T>} d
	 * @returns {Effect}
	 */
	function template_effect(fn, thunks = [], d = derived) {
		if (DEV) {
			// wrap the effect so that we can decorate stack trace with `in {expression}`
			// (TODO maybe there's a better approach?)
			return render_effect(() => {
				var outer = /** @type {Effect} */ (active_effect);
				var inner = () => fn(...deriveds.map(get));

				define_property(outer.fn, 'name', { value: '{expression}' });
				define_property(inner, 'name', { value: '{expression}' });

				const deriveds = thunks.map(d);
				block(inner);
			});
		}

		const deriveds = thunks.map(d);
		return block(() => fn(...deriveds.map(get)));
	}

	/**
	 * @param {(() => void)} fn
	 * @param {number} flags
	 */
	function block(fn, flags = 0) {
		return create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);
	}

	/**
	 * @param {(() => void)} fn
	 * @param {boolean} [push]
	 */
	function branch(fn, push = true) {
		return create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push);
	}

	/**
	 * @param {Effect} effect
	 */
	function execute_effect_teardown(effect) {
		var teardown = effect.teardown;
		if (teardown !== null) {
			const previously_destroying_effect = is_destroying_effect;
			const previous_reaction = active_reaction;
			set_is_destroying_effect(true);
			set_active_reaction(null);
			try {
				teardown.call(null);
			} finally {
				set_is_destroying_effect(previously_destroying_effect);
				set_active_reaction(previous_reaction);
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @param {boolean} remove_dom
	 * @returns {void}
	 */
	function destroy_effect_children(signal, remove_dom = false) {
		var effect = signal.first;
		signal.first = signal.last = null;

		while (effect !== null) {
			var next = effect.next;

			if ((effect.f & ROOT_EFFECT) !== 0) {
				// this is now an independent root
				effect.parent = null;
			} else {
				destroy_effect(effect, remove_dom);
			}

			effect = next;
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function destroy_block_effect_children(signal) {
		var effect = signal.first;

		while (effect !== null) {
			var next = effect.next;
			if ((effect.f & BRANCH_EFFECT) === 0) {
				destroy_effect(effect);
			}
			effect = next;
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} [remove_dom]
	 * @returns {void}
	 */
	function destroy_effect(effect, remove_dom = true) {
		var removed = false;

		if (
			(remove_dom || (effect.f & HEAD_EFFECT) !== 0) &&
			effect.nodes_start !== null &&
			effect.nodes_end !== null
		) {
			remove_effect_dom(effect.nodes_start, /** @type {TemplateNode} */ (effect.nodes_end));
			removed = true;
		}

		destroy_effect_children(effect, remove_dom && !removed);
		remove_reactions(effect, 0);
		set_signal_status(effect, DESTROYED);

		var transitions = effect.transitions;

		if (transitions !== null) {
			for (const transition of transitions) {
				transition.stop();
			}
		}

		execute_effect_teardown(effect);

		var parent = effect.parent;

		// If the parent doesn't have any children, then skip this work altogether
		if (parent !== null && parent.first !== null) {
			unlink_effect(effect);
		}

		if (DEV) {
			effect.component_function = null;
		}

		// `first` and `child` are nulled out in destroy_effect_children
		// we don't null out `parent` so that error propagation can work correctly
		effect.next =
			effect.prev =
			effect.teardown =
			effect.ctx =
			effect.deps =
			effect.fn =
			effect.nodes_start =
			effect.nodes_end =
				null;
	}

	/**
	 *
	 * @param {TemplateNode | null} node
	 * @param {TemplateNode} end
	 */
	function remove_effect_dom(node, end) {
		while (node !== null) {
			/** @type {TemplateNode | null} */
			var next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));

			node.remove();
			node = next;
		}
	}

	/**
	 * Detach an effect from the effect tree, freeing up memory and
	 * reducing the amount of work that happens on subsequent traversals
	 * @param {Effect} effect
	 */
	function unlink_effect(effect) {
		var parent = effect.parent;
		var prev = effect.prev;
		var next = effect.next;

		if (prev !== null) prev.next = next;
		if (next !== null) next.prev = prev;

		if (parent !== null) {
			if (parent.first === effect) parent.first = next;
			if (parent.last === effect) parent.last = prev;
		}
	}

	/**
	 * When a block effect is removed, we don't immediately destroy it or yank it
	 * out of the DOM, because it might have transitions. Instead, we 'pause' it.
	 * It stays around (in memory, and in the DOM) until outro transitions have
	 * completed, and if the state change is reversed then we _resume_ it.
	 * A paused effect does not update, and the DOM subtree becomes inert.
	 * @param {Effect} effect
	 * @param {() => void} [callback]
	 */
	function pause_effect(effect, callback) {
		/** @type {TransitionManager[]} */
		var transitions = [];

		pause_children(effect, transitions, true);

		run_out_transitions(transitions, () => {
			destroy_effect(effect);
			if (callback) callback();
		});
	}

	/**
	 * @param {TransitionManager[]} transitions
	 * @param {() => void} fn
	 */
	function run_out_transitions(transitions, fn) {
		var remaining = transitions.length;
		if (remaining > 0) {
			var check = () => --remaining || fn();
			for (var transition of transitions) {
				transition.out(check);
			}
		} else {
			fn();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {TransitionManager[]} transitions
	 * @param {boolean} local
	 */
	function pause_children(effect, transitions, local) {
		if ((effect.f & INERT) !== 0) return;
		effect.f ^= INERT;

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transitions.push(transition);
				}
			}
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call pause_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			pause_children(child, transitions, transparent ? local : false);
			child = sibling;
		}
	}

	/**
	 * The opposite of `pause_effect`. We call this if (for example)
	 * `x` becomes falsy then truthy: `{#if x}...{/if}`
	 * @param {Effect} effect
	 */
	function resume_effect(effect) {
		resume_children(effect, true);
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} local
	 */
	function resume_children(effect, local) {
		if ((effect.f & INERT) === 0) return;
		effect.f ^= INERT;

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call resume_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			resume_children(child, transparent ? local : false);
			child = sibling;
		}

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transition.in();
				}
			}
		}
	}

	/** @type {Array<() => void>} */
	let micro_tasks = [];

	function run_micro_tasks() {
		var tasks = micro_tasks;
		micro_tasks = [];
		run_all(tasks);
	}

	/**
	 * @param {() => void} fn
	 */
	function queue_micro_task(fn) {
		if (micro_tasks.length === 0) {
			queueMicrotask(run_micro_tasks);
		}

		micro_tasks.push(fn);
	}

	/** @import { Effect } from '#client' */

	/**
	 * @param {unknown} error
	 */
	function handle_error(error) {
		var effect = /** @type {Effect} */ (active_effect);

		if (DEV && error instanceof Error) {
			adjust_error(error, effect);
		}

		if ((effect.f & EFFECT_RAN) === 0) {
			// if the error occurred while creating this subtree, we let it
			// bubble up until it hits a boundary that can handle it
			if ((effect.f & BOUNDARY_EFFECT) === 0) {
				throw error;
			}

			// @ts-expect-error
			effect.fn(error);
		} else {
			// otherwise we bubble up the effect tree ourselves
			invoke_error_boundary(error, effect);
		}
	}

	/**
	 * @param {unknown} error
	 * @param {Effect | null} effect
	 */
	function invoke_error_boundary(error, effect) {
		while (effect !== null) {
			if ((effect.f & BOUNDARY_EFFECT) !== 0) {
				try {
					// @ts-expect-error
					effect.fn(error);
					return;
				} catch {}
			}

			effect = effect.parent;
		}

		throw error;
	}

	/** @type {WeakSet<Error>} */
	const adjusted_errors = new WeakSet();

	/**
	 * Add useful information to the error message/stack in development
	 * @param {Error} error
	 * @param {Effect} effect
	 */
	function adjust_error(error, effect) {
		if (adjusted_errors.has(error)) return;
		adjusted_errors.add(error);

		const message_descriptor = get_descriptor(error, 'message');

		// if the message was already changed and it's not configurable we can't change it
		// or it will throw a different error swallowing the original error
		if (message_descriptor && !message_descriptor.configurable) return;

		var indent = is_firefox ? '  ' : '\t';
		var component_stack = `\n${indent}in ${effect.fn?.name || '<unknown>'}`;
		var context = effect.ctx;

		while (context !== null) {
			component_stack += `\n${indent}in ${context.function?.[FILENAME].split('/').pop()}`;
			context = context.p;
		}

		define_property(error, 'message', {
			value: error.message + `\n${component_stack}\n`
		});

		if (error.stack) {
			// Filter out internal modules
			define_property(error, 'stack', {
				value: error.stack
					.split('\n')
					.filter((line) => !line.includes('svelte/src/internal'))
					.join('\n')
			});
		}
	}

	/** @import { Derived, Effect, Reaction, Signal, Source, Value } from '#client' */

	let is_flushing = false;

	/** @type {Effect | null} */
	let last_scheduled_effect = null;

	let is_updating_effect = false;

	let is_destroying_effect = false;

	/** @param {boolean} value */
	function set_is_destroying_effect(value) {
		is_destroying_effect = value;
	}

	// Handle effect queues

	/** @type {Effect[]} */
	let queued_root_effects = [];

	/** @type {Effect[]} Stack of effects, dev only */
	let dev_effect_stack = [];
	// Handle signal reactivity tree dependencies and reactions

	/** @type {null | Reaction} */
	let active_reaction = null;

	let untracking = false;

	/** @param {null | Reaction} reaction */
	function set_active_reaction(reaction) {
		active_reaction = reaction;
	}

	/** @type {null | Effect} */
	let active_effect = null;

	/** @param {null | Effect} effect */
	function set_active_effect(effect) {
		active_effect = effect;
	}

	/**
	 * When sources are created within a reaction, reading and writing
	 * them within that reaction should not cause a re-run
	 * @type {null | [active_reaction: Reaction, sources: Source[]]}
	 */
	let reaction_sources = null;

	/** @param {Value} value */
	function push_reaction_value(value) {
		if (active_reaction !== null && active_reaction.f & EFFECT_IS_UPDATING) {
			if (reaction_sources === null) {
				reaction_sources = [active_reaction, [value]];
			} else {
				reaction_sources[1].push(value);
			}
		}
	}

	/**
	 * The dependencies of the reaction that is currently being executed. In many cases,
	 * the dependencies are unchanged between runs, and so this will be `null` unless
	 * and until a new dependency is accessed — we track this via `skipped_deps`
	 * @type {null | Value[]}
	 */
	let new_deps = null;

	let skipped_deps = 0;

	/**
	 * Tracks writes that the effect it's executed in doesn't listen to yet,
	 * so that the dependency can be added to the effect later on if it then reads it
	 * @type {null | Source[]}
	 */
	let untracked_writes = null;

	/** @param {null | Source[]} value */
	function set_untracked_writes(value) {
		untracked_writes = value;
	}

	/**
	 * @type {number} Used by sources and deriveds for handling updates.
	 * Version starts from 1 so that unowned deriveds differentiate between a created effect and a run one for tracing
	 **/
	let write_version = 1;

	/** @type {number} Used to version each read of a source of derived to avoid duplicating depedencies inside a reaction */
	let read_version = 0;

	// If we are working with a get() chain that has no active container,
	// to prevent memory leaks, we skip adding the reaction.
	let skip_reaction = false;

	function increment_write_version() {
		return ++write_version;
	}

	/**
	 * Determines whether a derived or effect is dirty.
	 * If it is MAYBE_DIRTY, will set the status to CLEAN
	 * @param {Reaction} reaction
	 * @returns {boolean}
	 */
	function check_dirtiness(reaction) {
		var flags = reaction.f;

		if ((flags & DIRTY) !== 0) {
			return true;
		}

		if ((flags & MAYBE_DIRTY) !== 0) {
			var dependencies = reaction.deps;
			var is_unowned = (flags & UNOWNED) !== 0;

			if (dependencies !== null) {
				var i;
				var dependency;
				var is_disconnected = (flags & DISCONNECTED) !== 0;
				var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
				var length = dependencies.length;

				// If we are working with a disconnected or an unowned signal that is now connected (due to an active effect)
				// then we need to re-connect the reaction to the dependency
				if (is_disconnected || is_unowned_connected) {
					var derived = /** @type {Derived} */ (reaction);
					var parent = derived.parent;

					for (i = 0; i < length; i++) {
						dependency = dependencies[i];

						// We always re-add all reactions (even duplicates) if the derived was
						// previously disconnected, however we don't if it was unowned as we
						// de-duplicate dependencies in that case
						if (is_disconnected || !dependency?.reactions?.includes(derived)) {
							(dependency.reactions ??= []).push(derived);
						}
					}

					if (is_disconnected) {
						derived.f ^= DISCONNECTED;
					}
					// If the unowned derived is now fully connected to the graph again (it's unowned and reconnected, has a parent
					// and the parent is not unowned), then we can mark it as connected again, removing the need for the unowned
					// flag
					if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {
						derived.f ^= UNOWNED;
					}
				}

				for (i = 0; i < length; i++) {
					dependency = dependencies[i];

					if (check_dirtiness(/** @type {Derived} */ (dependency))) {
						update_derived(/** @type {Derived} */ (dependency));
					}

					if (dependency.wv > reaction.wv) {
						return true;
					}
				}
			}

			// Unowned signals should never be marked as clean unless they
			// are used within an active_effect without skip_reaction
			if (!is_unowned || (active_effect !== null && !skip_reaction)) {
				set_signal_status(reaction, CLEAN);
			}
		}

		return false;
	}

	/**
	 * @param {Value} signal
	 * @param {Effect} effect
	 * @param {boolean} [root]
	 */
	function schedule_possible_effect_self_invalidation(signal, effect, root = true) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		for (var i = 0; i < reactions.length; i++) {
			var reaction = reactions[i];

			if (reaction_sources?.[1].includes(signal) && reaction_sources[0] === active_reaction) continue;

			if ((reaction.f & DERIVED) !== 0) {
				schedule_possible_effect_self_invalidation(/** @type {Derived} */ (reaction), effect, false);
			} else if (effect === reaction) {
				if (root) {
					set_signal_status(reaction, DIRTY);
				} else if ((reaction.f & CLEAN) !== 0) {
					set_signal_status(reaction, MAYBE_DIRTY);
				}
				schedule_effect(/** @type {Effect} */ (reaction));
			}
		}
	}

	/** @param {Reaction} reaction */
	function update_reaction(reaction) {
		var previous_deps = new_deps;
		var previous_skipped_deps = skipped_deps;
		var previous_untracked_writes = untracked_writes;
		var previous_reaction = active_reaction;
		var previous_skip_reaction = skip_reaction;
		var previous_reaction_sources = reaction_sources;
		var previous_component_context = component_context;
		var previous_untracking = untracking;

		var flags = reaction.f;

		new_deps = /** @type {null | Value[]} */ (null);
		skipped_deps = 0;
		untracked_writes = null;
		skip_reaction =
			(flags & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);
		active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;

		reaction_sources = null;
		set_component_context(reaction.ctx);
		untracking = false;
		read_version++;

		reaction.f |= EFFECT_IS_UPDATING;

		try {
			var result = /** @type {Function} */ (0, reaction.fn)();
			var deps = reaction.deps;

			if (new_deps !== null) {
				var i;

				remove_reactions(reaction, skipped_deps);

				if (deps !== null && skipped_deps > 0) {
					deps.length = skipped_deps + new_deps.length;
					for (i = 0; i < new_deps.length; i++) {
						deps[skipped_deps + i] = new_deps[i];
					}
				} else {
					reaction.deps = deps = new_deps;
				}

				if (!skip_reaction) {
					for (i = skipped_deps; i < deps.length; i++) {
						(deps[i].reactions ??= []).push(reaction);
					}
				}
			} else if (deps !== null && skipped_deps < deps.length) {
				remove_reactions(reaction, skipped_deps);
				deps.length = skipped_deps;
			}

			// If we're inside an effect and we have untracked writes, then we need to
			// ensure that if any of those untracked writes result in re-invalidation
			// of the current effect, then that happens accordingly
			if (
				is_runes() &&
				untracked_writes !== null &&
				!untracking &&
				deps !== null &&
				(reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0
			) {
				for (i = 0; i < /** @type {Source[]} */ (untracked_writes).length; i++) {
					schedule_possible_effect_self_invalidation(
						untracked_writes[i],
						/** @type {Effect} */ (reaction)
					);
				}
			}

			// If we are returning to an previous reaction then
			// we need to increment the read version to ensure that
			// any dependencies in this reaction aren't marked with
			// the same version
			if (previous_reaction !== null && previous_reaction !== reaction) {
				read_version++;

				if (untracked_writes !== null) {
					if (previous_untracked_writes === null) {
						previous_untracked_writes = untracked_writes;
					} else {
						previous_untracked_writes.push(.../** @type {Source[]} */ (untracked_writes));
					}
				}
			}

			return result;
		} catch (error) {
			handle_error(error);
		} finally {
			new_deps = previous_deps;
			skipped_deps = previous_skipped_deps;
			untracked_writes = previous_untracked_writes;
			active_reaction = previous_reaction;
			skip_reaction = previous_skip_reaction;
			reaction_sources = previous_reaction_sources;
			set_component_context(previous_component_context);
			untracking = previous_untracking;

			reaction.f ^= EFFECT_IS_UPDATING;
		}
	}

	/**
	 * @template V
	 * @param {Reaction} signal
	 * @param {Value<V>} dependency
	 * @returns {void}
	 */
	function remove_reaction(signal, dependency) {
		let reactions = dependency.reactions;
		if (reactions !== null) {
			var index = index_of.call(reactions, signal);
			if (index !== -1) {
				var new_length = reactions.length - 1;
				if (new_length === 0) {
					reactions = dependency.reactions = null;
				} else {
					// Swap with last element and then remove.
					reactions[index] = reactions[new_length];
					reactions.pop();
				}
			}
		}
		// If the derived has no reactions, then we can disconnect it from the graph,
		// allowing it to either reconnect in the future, or be GC'd by the VM.
		if (
			reactions === null &&
			(dependency.f & DERIVED) !== 0 &&
			// Destroying a child effect while updating a parent effect can cause a dependency to appear
			// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
			// allows us to skip the expensive work of disconnecting and immediately reconnecting it
			(new_deps === null || !new_deps.includes(dependency))
		) {
			set_signal_status(dependency, MAYBE_DIRTY);
			// If we are working with a derived that is owned by an effect, then mark it as being
			// disconnected.
			if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
				dependency.f ^= DISCONNECTED;
			}
			// Disconnect any reactions owned by this reaction
			destroy_derived_effects(/** @type {Derived} **/ (dependency));
			remove_reactions(/** @type {Derived} **/ (dependency), 0);
		}
	}

	/**
	 * @param {Reaction} signal
	 * @param {number} start_index
	 * @returns {void}
	 */
	function remove_reactions(signal, start_index) {
		var dependencies = signal.deps;
		if (dependencies === null) return;

		for (var i = start_index; i < dependencies.length; i++) {
			remove_reaction(signal, dependencies[i]);
		}
	}

	/**
	 * @param {Effect} effect
	 * @returns {void}
	 */
	function update_effect(effect) {
		var flags = effect.f;

		if ((flags & DESTROYED) !== 0) {
			return;
		}

		set_signal_status(effect, CLEAN);

		var previous_effect = active_effect;
		var was_updating_effect = is_updating_effect;

		active_effect = effect;
		is_updating_effect = true;

		if (DEV) {
			var previous_component_fn = dev_current_component_function;
			set_dev_current_component_function(effect.component_function);
		}

		try {
			if ((flags & BLOCK_EFFECT) !== 0) {
				destroy_block_effect_children(effect);
			} else {
				destroy_effect_children(effect);
			}

			execute_effect_teardown(effect);
			var teardown = update_reaction(effect);
			effect.teardown = typeof teardown === 'function' ? teardown : null;
			effect.wv = write_version;

			// In DEV, increment versions of any sources that were written to during the effect,
			// so that they are correctly marked as dirty when the effect re-runs
			if (DEV && tracing_mode_flag && (effect.f & DIRTY) !== 0 && effect.deps !== null) {
				for (var dep of effect.deps) {
					if (dep.set_during_effect) {
						dep.wv = increment_write_version();
						dep.set_during_effect = false;
					}
				}
			}

			if (DEV) {
				dev_effect_stack.push(effect);
			}
		} finally {
			is_updating_effect = was_updating_effect;
			active_effect = previous_effect;

			if (DEV) {
				set_dev_current_component_function(previous_component_fn);
			}
		}
	}

	function log_effect_stack() {
		// eslint-disable-next-line no-console
		console.error(
			'Last ten effects were: ',
			dev_effect_stack.slice(-10).map((d) => d.fn)
		);
		dev_effect_stack = [];
	}

	function infinite_loop_guard() {
		try {
			effect_update_depth_exceeded();
		} catch (error) {
			if (DEV) {
				// stack is garbage, ignore. Instead add a console.error message.
				define_property(error, 'stack', {
					value: ''
				});
			}
			// Try and handle the error so it can be caught at a boundary, that's
			// if there's an effect available from when it was last scheduled
			if (last_scheduled_effect !== null) {
				if (DEV) {
					try {
						invoke_error_boundary(error, last_scheduled_effect);
					} catch (e) {
						// Only log the effect stack if the error is re-thrown
						log_effect_stack();
						throw e;
					}
				} else {
					invoke_error_boundary(error, last_scheduled_effect);
				}
			} else {
				if (DEV) {
					log_effect_stack();
				}
				throw error;
			}
		}
	}

	function flush_queued_root_effects() {
		var was_updating_effect = is_updating_effect;

		try {
			var flush_count = 0;
			is_updating_effect = true;

			while (queued_root_effects.length > 0) {
				if (flush_count++ > 1000) {
					infinite_loop_guard();
				}

				var root_effects = queued_root_effects;
				var length = root_effects.length;

				queued_root_effects = [];

				for (var i = 0; i < length; i++) {
					var collected_effects = process_effects(root_effects[i]);
					flush_queued_effects(collected_effects);
				}
				old_values.clear();
			}
		} finally {
			is_flushing = false;
			is_updating_effect = was_updating_effect;

			last_scheduled_effect = null;
			if (DEV) {
				dev_effect_stack = [];
			}
		}
	}

	/**
	 * @param {Array<Effect>} effects
	 * @returns {void}
	 */
	function flush_queued_effects(effects) {
		var length = effects.length;
		if (length === 0) return;

		for (var i = 0; i < length; i++) {
			var effect = effects[i];

			if ((effect.f & (DESTROYED | INERT)) === 0) {
				if (check_dirtiness(effect)) {
					update_effect(effect);

					// Effects with no dependencies or teardown do not get added to the effect tree.
					// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we
					// don't know if we need to keep them until they are executed. Doing the check
					// here (rather than in `update_effect`) allows us to skip the work for
					// immediate effects.
					if (effect.deps === null && effect.first === null && effect.nodes_start === null) {
						if (effect.teardown === null) {
							// remove this effect from the graph
							unlink_effect(effect);
						} else {
							// keep the effect in the graph, but free up some memory
							effect.fn = null;
						}
					}
				}
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function schedule_effect(signal) {
		if (!is_flushing) {
			is_flushing = true;
			queueMicrotask(flush_queued_root_effects);
		}

		var effect = (last_scheduled_effect = signal);

		while (effect.parent !== null) {
			effect = effect.parent;
			var flags = effect.f;

			if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
				if ((flags & CLEAN) === 0) return;
				effect.f ^= CLEAN;
			}
		}

		queued_root_effects.push(effect);
	}

	/**
	 *
	 * This function both runs render effects and collects user effects in topological order
	 * from the starting effect passed in. Effects will be collected when they match the filtered
	 * bitwise flag passed in only. The collected effects array will be populated with all the user
	 * effects to be flushed.
	 *
	 * @param {Effect} root
	 * @returns {Effect[]}
	 */
	function process_effects(root) {
		/** @type {Effect[]} */
		var effects = [];

		/** @type {Effect | null} */
		var effect = root;

		while (effect !== null) {
			var flags = effect.f;
			var is_branch = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
			var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;

			if (!is_skippable_branch && (flags & INERT) === 0) {
				if ((flags & EFFECT) !== 0) {
					effects.push(effect);
				} else if (is_branch) {
					effect.f ^= CLEAN;
				} else {
					if (check_dirtiness(effect)) {
						update_effect(effect);
					}
				}

				/** @type {Effect | null} */
				var child = effect.first;

				if (child !== null) {
					effect = child;
					continue;
				}
			}

			var parent = effect.parent;
			effect = effect.next;

			while (effect === null && parent !== null) {
				effect = parent.next;
				parent = parent.parent;
			}
		}

		return effects;
	}

	/**
	 * @template V
	 * @param {Value<V>} signal
	 * @returns {V}
	 */
	function get(signal) {
		var flags = signal.f;
		var is_derived = (flags & DERIVED) !== 0;

		// Register the dependency on the current reaction signal.
		if (active_reaction !== null && !untracking) {
			if (!reaction_sources?.[1].includes(signal) || reaction_sources[0] !== active_reaction) {
				var deps = active_reaction.deps;
				if (signal.rv < read_version) {
					signal.rv = read_version;
					// If the signal is accessing the same dependencies in the same
					// order as it did last time, increment `skipped_deps`
					// rather than updating `new_deps`, which creates GC cost
					if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
						skipped_deps++;
					} else if (new_deps === null) {
						new_deps = [signal];
					} else if (!skip_reaction || !new_deps.includes(signal)) {
						// Normally we can push duplicated dependencies to `new_deps`, but if we're inside
						// an unowned derived because skip_reaction is true, then we need to ensure that
						// we don't have duplicates
						new_deps.push(signal);
					}
				}
			}
		} else if (
			is_derived &&
			/** @type {Derived} */ (signal).deps === null &&
			/** @type {Derived} */ (signal).effects === null
		) {
			var derived = /** @type {Derived} */ (signal);
			var parent = derived.parent;

			if (parent !== null && (parent.f & UNOWNED) === 0) {
				// If the derived is owned by another derived then mark it as unowned
				// as the derived value might have been referenced in a different context
				// since and thus its parent might not be its true owner anymore
				derived.f ^= UNOWNED;
			}
		}

		if (is_derived) {
			derived = /** @type {Derived} */ (signal);

			if (check_dirtiness(derived)) {
				update_derived(derived);
			}
		}

		if (
			DEV &&
			tracing_mode_flag &&
			!untracking &&
			tracing_expressions !== null &&
			active_reaction !== null &&
			tracing_expressions.reaction === active_reaction
		) {
			// Used when mapping state between special blocks like `each`
			if (signal.trace) {
				signal.trace();
			} else {
				var trace = get_stack('TracedAt');

				if (trace) {
					var entry = tracing_expressions.entries.get(signal);

					if (entry === undefined) {
						entry = { traces: [] };
						tracing_expressions.entries.set(signal, entry);
					}

					var last = entry.traces[entry.traces.length - 1];

					// traces can be duplicated, e.g. by `snapshot` invoking both
					// both `getOwnPropertyDescriptor` and `get` traps at once
					if (trace.stack !== last?.stack) {
						entry.traces.push(trace);
					}
				}
			}
		}

		if (is_destroying_effect && old_values.has(signal)) {
			return old_values.get(signal);
		}

		return signal.v;
	}

	/**
	 * When used inside a [`$derived`](https://svelte.dev/docs/svelte/$derived) or [`$effect`](https://svelte.dev/docs/svelte/$effect),
	 * any state read inside `fn` will not be treated as a dependency.
	 *
	 * ```ts
	 * $effect(() => {
	 *   // this will run when `data` changes, but not when `time` changes
	 *   save(data, {
	 *     timestamp: untrack(() => time)
	 *   });
	 * });
	 * ```
	 * @template T
	 * @param {() => T} fn
	 * @returns {T}
	 */
	function untrack(fn) {
		var previous_untracking = untracking;
		try {
			untracking = true;
			return fn();
		} finally {
			untracking = previous_untracking;
		}
	}

	const STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);

	/**
	 * @param {Signal} signal
	 * @param {number} status
	 * @returns {void}
	 */
	function set_signal_status(signal, status) {
		signal.f = (signal.f & STATUS_MASK) | status;
	}

	/** @type {Set<string>} */
	const all_registered_events = new Set();

	/** @type {Set<(events: Array<string>) => void>} */
	const root_event_handles = new Set();

	/**
	 * @param {Array<string>} events
	 * @returns {void}
	 */
	function delegate(events) {
		for (var i = 0; i < events.length; i++) {
			all_registered_events.add(events[i]);
		}

		for (var fn of root_event_handles) {
			fn(events);
		}
	}

	/**
	 * @this {EventTarget}
	 * @param {Event} event
	 * @returns {void}
	 */
	function handle_event_propagation(event) {
		var handler_element = this;
		var owner_document = /** @type {Node} */ (handler_element).ownerDocument;
		var event_name = event.type;
		var path = event.composedPath?.() || [];
		var current_target = /** @type {null | Element} */ (path[0] || event.target);

		// composedPath contains list of nodes the event has propagated through.
		// We check __root to skip all nodes below it in case this is a
		// parent of the __root node, which indicates that there's nested
		// mounted apps. In this case we don't want to trigger events multiple times.
		var path_idx = 0;

		// @ts-expect-error is added below
		var handled_at = event.__root;

		if (handled_at) {
			var at_idx = path.indexOf(handled_at);
			if (
				at_idx !== -1 &&
				(handler_element === document || handler_element === /** @type {any} */ (window))
			) {
				// This is the fallback document listener or a window listener, but the event was already handled
				// -> ignore, but set handle_at to document/window so that we're resetting the event
				// chain in case someone manually dispatches the same event object again.
				// @ts-expect-error
				event.__root = handler_element;
				return;
			}

			// We're deliberately not skipping if the index is higher, because
			// someone could create an event programmatically and emit it multiple times,
			// in which case we want to handle the whole propagation chain properly each time.
			// (this will only be a false negative if the event is dispatched multiple times and
			// the fallback document listener isn't reached in between, but that's super rare)
			var handler_idx = path.indexOf(handler_element);
			if (handler_idx === -1) {
				// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)
				// so guard against that, too, and assume that everything was handled at this point.
				return;
			}

			if (at_idx <= handler_idx) {
				path_idx = at_idx;
			}
		}

		current_target = /** @type {Element} */ (path[path_idx] || event.target);
		// there can only be one delegated event per element, and we either already handled the current target,
		// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe
		// to handle a possible delegated event on it later (through the root delegation listener for example).
		if (current_target === handler_element) return;

		// Proxy currentTarget to correct target
		define_property(event, 'currentTarget', {
			configurable: true,
			get() {
				return current_target || owner_document;
			}
		});

		// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,
		// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic
		// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,
		// it's probably best that all event handled by Svelte have this behaviour, as we don't really want
		// an event handler to run in the context of another reaction or effect.
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);

		try {
			/**
			 * @type {unknown}
			 */
			var throw_error;
			/**
			 * @type {unknown[]}
			 */
			var other_errors = [];

			while (current_target !== null) {
				/** @type {null | Element} */
				var parent_element =
					current_target.assignedSlot ||
					current_target.parentNode ||
					/** @type {any} */ (current_target).host ||
					null;

				try {
					// @ts-expect-error
					var delegated = current_target['__' + event_name];

					if (
						delegated != null &&
						(!(/** @type {any} */ (current_target).disabled) ||
							// DOM could've been updated already by the time this is reached, so we check this as well
							// -> the target could not have been disabled because it emits the event in the first place
							event.target === current_target)
					) {
						if (is_array(delegated)) {
							var [fn, ...data] = delegated;
							fn.apply(current_target, [event, ...data]);
						} else {
							delegated.call(current_target, event);
						}
					}
				} catch (error) {
					if (throw_error) {
						other_errors.push(error);
					} else {
						throw_error = error;
					}
				}
				if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
					break;
				}
				current_target = parent_element;
			}

			if (throw_error) {
				for (let error of other_errors) {
					// Throw the rest of the errors, one-by-one on a microtask
					queueMicrotask(() => {
						throw error;
					});
				}
				throw throw_error;
			}
		} finally {
			// @ts-expect-error is used above
			event.__root = handler_element;
			// @ts-ignore remove proxy on currentTarget
			delete event.currentTarget;
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/** @param {string} html */
	function create_fragment_from_html(html) {
		var elem = document.createElement('template');
		elem.innerHTML = html.replaceAll('<!>', '<!---->'); // XHTML compliance
		return elem.content;
	}

	/** @import { Effect, TemplateNode } from '#client' */
	/** @import { TemplateStructure } from './types' */

	/**
	 * @param {TemplateNode} start
	 * @param {TemplateNode | null} end
	 */
	function assign_nodes(start, end) {
		var effect = /** @type {Effect} */ (active_effect);
		if (effect.nodes_start === null) {
			effect.nodes_start = start;
			effect.nodes_end = end;
		}
	}

	/**
	 * @param {string} content
	 * @param {number} flags
	 * @returns {() => Node | Node[]}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function from_html(content, flags) {
		var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
		var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;

		/** @type {Node} */
		var node;

		/**
		 * Whether or not the first item is a text/element node. If not, we need to
		 * create an additional comment node to act as `effect.nodes.start`
		 */
		var has_start = !content.startsWith('<!>');

		return () => {

			if (node === undefined) {
				node = create_fragment_from_html(has_start ? content : '<!>' + content);
				if (!is_fragment) node = /** @type {Node} */ (get_first_child(node));
			}

			var clone = /** @type {TemplateNode} */ (
				use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
			);

			if (is_fragment) {
				var start = /** @type {TemplateNode} */ (get_first_child(clone));
				var end = /** @type {TemplateNode} */ (clone.lastChild);

				assign_nodes(start, end);
			} else {
				assign_nodes(clone, clone);
			}

			return clone;
		};
	}

	/**
	 * Assign the created (or in hydration mode, traversed) dom elements to the current block
	 * and insert the elements into the dom (in client mode).
	 * @param {Text | Comment | Element} anchor
	 * @param {DocumentFragment | Element} dom
	 */
	function append(anchor, dom) {

		if (anchor === null) {
			// edge case — void `<svelte:element>` with content
			return;
		}

		anchor.before(/** @type {Node} */ (dom));
	}

	/**
	 * Subset of delegated events which should be passive by default.
	 * These two are already passive via browser defaults on window, document and body.
	 * But since
	 * - we're delegating them
	 * - they happen often
	 * - they apply to mobile which is generally less performant
	 * we're marking them as passive by default for other elements, too.
	 */
	const PASSIVE_EVENTS = ['touchstart', 'touchmove'];

	/**
	 * Returns `true` if `name` is a passive event
	 * @param {string} name
	 */
	function is_passive_event(name) {
		return PASSIVE_EVENTS.includes(name);
	}

	/** @import { ComponentContext, Effect, TemplateNode } from '#client' */
	/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */

	/**
	 * @param {Element} text
	 * @param {string} value
	 * @returns {void}
	 */
	function set_text(text, value) {
		// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing
		var str = value == null ? '' : typeof value === 'object' ? value + '' : value;
		// @ts-expect-error
		if (str !== (text.__t ??= text.nodeValue)) {
			// @ts-expect-error
			text.__t = str;
			text.nodeValue = str + '';
		}
	}

	/**
	 * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.
	 * Transitions will play during the initial render unless the `intro` option is set to `false`.
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
	 * @param {MountOptions<Props>} options
	 * @returns {Exports}
	 */
	function mount(component, options) {
		return _mount(component, options);
	}

	/** @type {Map<string, number>} */
	const document_listeners = new Map();

	/**
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component
	 * @param {MountOptions} options
	 * @returns {Exports}
	 */
	function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
		init_operations();

		var registered_events = new Set();

		/** @param {Array<string>} events */
		var event_handle = (events) => {
			for (var i = 0; i < events.length; i++) {
				var event_name = events[i];

				if (registered_events.has(event_name)) continue;
				registered_events.add(event_name);

				var passive = is_passive_event(event_name);

				// Add the event listener to both the container and the document.
				// The container listener ensures we catch events from within in case
				// the outer content stops propagation of the event.
				target.addEventListener(event_name, handle_event_propagation, { passive });

				var n = document_listeners.get(event_name);

				if (n === undefined) {
					// The document listener ensures we catch events that originate from elements that were
					// manually moved outside of the container (e.g. via manual portals).
					document.addEventListener(event_name, handle_event_propagation, { passive });
					document_listeners.set(event_name, 1);
				} else {
					document_listeners.set(event_name, n + 1);
				}
			}
		};

		event_handle(array_from(all_registered_events));
		root_event_handles.add(event_handle);

		/** @type {Exports} */
		// @ts-expect-error will be defined because the render effect runs synchronously
		var component = undefined;

		var unmount = component_root(() => {
			var anchor_node = anchor ?? target.appendChild(create_text());

			branch(() => {
				if (context) {
					push({});
					var ctx = /** @type {ComponentContext} */ (component_context);
					ctx.c = context;
				}

				if (events) {
					// We can't spread the object or else we'd lose the state proxy stuff, if it is one
					/** @type {any} */ (props).$$events = events;
				}
				// @ts-expect-error the public typings are not what the actual function looks like
				component = Component(anchor_node, props) || {};

				if (context) {
					pop();
				}
			});

			return () => {
				for (var event_name of registered_events) {
					target.removeEventListener(event_name, handle_event_propagation);

					var n = /** @type {number} */ (document_listeners.get(event_name));

					if (--n === 0) {
						document.removeEventListener(event_name, handle_event_propagation);
						document_listeners.delete(event_name);
					} else {
						document_listeners.set(event_name, n);
					}
				}

				root_event_handles.delete(event_handle);

				if (anchor_node !== anchor) {
					anchor_node.parentNode?.removeChild(anchor_node);
				}
			};
		});

		mounted_components.set(component, unmount);
		return component;
	}

	/**
	 * References of the components that were mounted or hydrated.
	 * Uses a `WeakMap` to avoid memory leaks.
	 */
	let mounted_components = new WeakMap();

	/** @import { ComponentContext, ComponentContextLegacy } from '#client' */
	/** @import { EventDispatcher } from './index.js' */
	/** @import { NotFunction } from './internal/types.js' */

	if (DEV) {
		/**
		 * @param {string} rune
		 */
		function throw_rune_error(rune) {
			if (!(rune in globalThis)) {
				// TODO if people start adjusting the "this can contain runes" config through v-p-s more, adjust this message
				/** @type {any} */
				let value; // let's hope noone modifies this global, but belts and braces
				Object.defineProperty(globalThis, rune, {
					configurable: true,
					// eslint-disable-next-line getter-return
					get: () => {
						if (value !== undefined) {
							return value;
						}

						rune_outside_svelte(rune);
					},
					set: (v) => {
						value = v;
					}
				});
			}
		}

		throw_rune_error('$state');
		throw_rune_error('$effect');
		throw_rune_error('$derived');
		throw_rune_error('$inspect');
		throw_rune_error('$props');
		throw_rune_error('$bindable');
	}

	/**
	 * `onMount`, like [`$effect`](https://svelte.dev/docs/svelte/$effect), schedules a function to run as soon as the component has been mounted to the DOM.
	 * Unlike `$effect`, the provided function only runs once.
	 *
	 * It must be called during the component's initialisation (but doesn't need to live _inside_ the component;
	 * it can be called from an external module). If a function is returned _synchronously_ from `onMount`,
	 * it will be called when the component is unmounted.
	 *
	 * `onMount` functions do not run during [server-side rendering](https://svelte.dev/docs/svelte/svelte-server#render).
	 *
	 * @template T
	 * @param {() => NotFunction<T> | Promise<NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
		if (component_context === null) {
			lifecycle_outside_component('onMount');
		}

		if (legacy_mode_flag && component_context.l !== null) {
			init_update_callbacks(component_context).m.push(fn);
		} else {
			user_effect(() => {
				const cleanup = untrack(fn);
				if (typeof cleanup === 'function') return /** @type {() => void} */ (cleanup);
			});
		}
	}

	/**
	 * Legacy-mode: Init callbacks object for onMount/beforeUpdate/afterUpdate
	 * @param {ComponentContext} context
	 */
	function init_update_callbacks(context) {
		var l = /** @type {ComponentContextLegacy} */ (context).l;
		return (l.u ??= { a: [], b: [], m: [] });
	}

	/** @import { SourceLocation } from '#client' */

	/**
	 * @param {any} fn
	 * @param {string} filename
	 * @param {SourceLocation[]} locations
	 * @returns {any}
	 */
	function add_locations(fn, filename, locations) {
		return (/** @type {any[]} */ ...args) => {
			const dom = fn(...args);

			var node = dom.nodeType === 11 ? dom.firstChild : dom;
			assign_locations(node, filename, locations);

			return dom;
		};
	}

	/**
	 * @param {Element} element
	 * @param {string} filename
	 * @param {SourceLocation} location
	 */
	function assign_location(element, filename, location) {
		// @ts-expect-error
		element.__svelte_meta = {
			loc: { file: filename, line: location[0], column: location[1] }
		};

		if (location[2]) {
			assign_locations(element.firstChild, filename, location[2]);
		}
	}

	/**
	 * @param {Node | null} node
	 * @param {string} filename
	 * @param {SourceLocation[]} locations
	 */
	function assign_locations(node, filename, locations) {
		var i = 0;

		while (node && i < locations.length) {

			if (node.nodeType === 1) {
				assign_location(/** @type {Element} */ (node), filename, locations[i++]);
			}

			node = node.nextSibling;
		}
	}

	/** @param {Function & { [FILENAME]: string }} target */
	function check_target(target) {
		if (target) {
			component_api_invalid_new(target[FILENAME] ?? 'a component', target.name);
		}
	}

	function legacy_api() {
		const component = component_context?.function;

		/** @param {string} method */
		function error(method) {
			component_api_changed(method, component[FILENAME]);
		}

		return {
			$destroy: () => error('$destroy()'),
			$on: () => error('$on(...)'),
			$set: () => error('$set(...)')
		};
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {TemplateNode} node
	 * @param {(branch: (fn: (anchor: Node, elseif?: [number,number]) => void, flag?: boolean) => void) => void} fn
	 * @param {[number,number]} [elseif]
	 * @returns {void}
	 */
	function if_block(node, fn, [root_index, hydrate_index] = [0, 0]) {

		var anchor = node;

		/** @type {Effect | null} */
		var consequent_effect = null;

		/** @type {Effect | null} */
		var alternate_effect = null;

		/** @type {UNINITIALIZED | boolean | null} */
		var condition = UNINITIALIZED;

		var flags = root_index > 0 ? EFFECT_TRANSPARENT : 0;

		var has_branch = false;

		const set_branch = (
			/** @type {(anchor: Node, elseif?: [number,number]) => void} */ fn,
			flag = true
		) => {
			has_branch = true;
			update_branch(flag, fn);
		};

		const update_branch = (
			/** @type {boolean | null} */ new_condition,
			/** @type {null | ((anchor: Node, elseif?: [number,number]) => void)} */ fn
		) => {
			if (condition === (condition = new_condition)) return;

			if (condition) {
				if (consequent_effect) {
					resume_effect(consequent_effect);
				} else if (fn) {
					consequent_effect = branch(() => fn(anchor));
				}

				if (alternate_effect) {
					pause_effect(alternate_effect, () => {
						alternate_effect = null;
					});
				}
			} else {
				if (alternate_effect) {
					resume_effect(alternate_effect);
				} else if (fn) {
					alternate_effect = branch(() => fn(anchor, [root_index + 1, hydrate_index]));
				}

				if (consequent_effect) {
					pause_effect(consequent_effect, () => {
						consequent_effect = null;
					});
				}
			}
		};

		block(() => {
			has_branch = false;
			fn(set_branch);
			if (!has_branch) {
				update_branch(null, null);
			}
		}, flags);
	}

	/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */

	/**
	 * @param {any} _
	 * @param {number} i
	 */
	function index(_, i) {
		return i;
	}

	/**
	 * Pause multiple effects simultaneously, and coordinate their
	 * subsequent destruction. Used in each blocks
	 * @param {EachState} state
	 * @param {EachItem[]} items
	 * @param {null | Node} controlled_anchor
	 * @param {Map<any, EachItem>} items_map
	 */
	function pause_effects(state, items, controlled_anchor, items_map) {
		/** @type {TransitionManager[]} */
		var transitions = [];
		var length = items.length;

		for (var i = 0; i < length; i++) {
			pause_children(items[i].e, transitions, true);
		}

		var is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;
		// If we have a controlled anchor, it means that the each block is inside a single
		// DOM element, so we can apply a fast-path for clearing the contents of the element.
		if (is_controlled) {
			var parent_node = /** @type {Element} */ (
				/** @type {Element} */ (controlled_anchor).parentNode
			);
			clear_text_content(parent_node);
			parent_node.append(/** @type {Element} */ (controlled_anchor));
			items_map.clear();
			link(state, items[0].prev, items[length - 1].next);
		}

		run_out_transitions(transitions, () => {
			for (var i = 0; i < length; i++) {
				var item = items[i];
				if (!is_controlled) {
					items_map.delete(item.k);
					link(state, item.prev, item.next);
				}
				destroy_effect(item.e, !is_controlled);
			}
		});
	}

	/**
	 * @template V
	 * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @param {(value: V, index: number) => any} get_key
	 * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn
	 * @param {null | ((anchor: Node) => void)} fallback_fn
	 * @returns {void}
	 */
	function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {
		var anchor = node;

		/** @type {EachState} */
		var state = { flags, items: new Map(), first: null };

		var is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;

		if (is_controlled) {
			var parent_node = /** @type {Element} */ (node);

			anchor = parent_node.appendChild(create_text());
		}

		/** @type {Effect | null} */
		var fallback = null;

		var was_empty = false;

		// TODO: ideally we could use derived for runes mode but because of the ability
		// to use a store which can be mutated, we can't do that here as mutating a store
		// will still result in the collection array being the same from the store
		var each_array = derived_safe_equal(() => {
			var collection = get_collection();

			return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
		});

		block(() => {
			var array = get(each_array);
			var length = array.length;

			if (was_empty && length === 0) {
				// ignore updates if the array is empty,
				// and it already was empty on previous run
				return;
			}
			was_empty = length === 0;

			{
				reconcile(array, state, anchor, render_fn, flags, get_key, get_collection);
			}

			if (fallback_fn !== null) {
				if (length === 0) {
					if (fallback) {
						resume_effect(fallback);
					} else {
						fallback = branch(() => fallback_fn(anchor));
					}
				} else if (fallback !== null) {
					pause_effect(fallback, () => {
						fallback = null;
					});
				}
			}

			// When we mount the each block for the first time, the collection won't be
			// connected to this effect as the effect hasn't finished running yet and its deps
			// won't be assigned. However, it's possible that when reconciling the each block
			// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the
			// collection again can provide consistency to the reactive graph again as the deriveds
			// will now be `CLEAN`.
			get(each_array);
		});
	}

	/**
	 * Add, remove, or reorder items output by an each block as its input changes
	 * @template V
	 * @param {Array<V>} array
	 * @param {EachState} state
	 * @param {Element | Comment | Text} anchor
	 * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>, collection: () => V[]) => void} render_fn
	 * @param {number} flags
	 * @param {(value: V, index: number) => any} get_key
	 * @param {() => V[]} get_collection
	 * @returns {void}
	 */
	function reconcile(array, state, anchor, render_fn, flags, get_key, get_collection) {
		var is_animated = (flags & EACH_IS_ANIMATED) !== 0;
		var should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;

		var length = array.length;
		var items = state.items;
		var first = state.first;
		var current = first;

		/** @type {undefined | Set<EachItem>} */
		var seen;

		/** @type {EachItem | null} */
		var prev = null;

		/** @type {undefined | Set<EachItem>} */
		var to_animate;

		/** @type {EachItem[]} */
		var matched = [];

		/** @type {EachItem[]} */
		var stashed = [];

		/** @type {V} */
		var value;

		/** @type {any} */
		var key;

		/** @type {EachItem | undefined} */
		var item;

		/** @type {number} */
		var i;

		if (is_animated) {
			for (i = 0; i < length; i += 1) {
				value = array[i];
				key = get_key(value, i);
				item = items.get(key);

				if (item !== undefined) {
					item.a?.measure();
					(to_animate ??= new Set()).add(item);
				}
			}
		}

		for (i = 0; i < length; i += 1) {
			value = array[i];
			key = get_key(value, i);
			item = items.get(key);

			if (item === undefined) {
				var child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;

				prev = create_item(
					child_anchor,
					state,
					prev,
					prev === null ? state.first : prev.next,
					value,
					key,
					i,
					render_fn,
					flags,
					get_collection
				);

				items.set(key, prev);

				matched = [];
				stashed = [];

				current = prev.next;
				continue;
			}

			if (should_update) {
				update_item(item, value, i, flags);
			}

			if ((item.e.f & INERT) !== 0) {
				resume_effect(item.e);
				if (is_animated) {
					item.a?.unfix();
					(to_animate ??= new Set()).delete(item);
				}
			}

			if (item !== current) {
				if (seen !== undefined && seen.has(item)) {
					if (matched.length < stashed.length) {
						// more efficient to move later items to the front
						var start = stashed[0];
						var j;

						prev = start.prev;

						var a = matched[0];
						var b = matched[matched.length - 1];

						for (j = 0; j < matched.length; j += 1) {
							move(matched[j], start, anchor);
						}

						for (j = 0; j < stashed.length; j += 1) {
							seen.delete(stashed[j]);
						}

						link(state, a.prev, b.next);
						link(state, prev, a);
						link(state, b, start);

						current = start;
						prev = b;
						i -= 1;

						matched = [];
						stashed = [];
					} else {
						// more efficient to move earlier items to the back
						seen.delete(item);
						move(item, current, anchor);

						link(state, item.prev, item.next);
						link(state, item, prev === null ? state.first : prev.next);
						link(state, prev, item);

						prev = item;
					}

					continue;
				}

				matched = [];
				stashed = [];

				while (current !== null && current.k !== key) {
					// If the each block isn't inert and an item has an effect that is already inert,
					// skip over adding it to our seen Set as the item is already being handled
					if ((current.e.f & INERT) === 0) {
						(seen ??= new Set()).add(current);
					}
					stashed.push(current);
					current = current.next;
				}

				if (current === null) {
					continue;
				}

				item = current;
			}

			matched.push(item);
			prev = item;
			current = item.next;
		}

		if (current !== null || seen !== undefined) {
			var to_destroy = seen === undefined ? [] : array_from(seen);

			while (current !== null) {
				// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished
				if ((current.e.f & INERT) === 0) {
					to_destroy.push(current);
				}
				current = current.next;
			}

			var destroy_length = to_destroy.length;

			if (destroy_length > 0) {
				var controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;

				if (is_animated) {
					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.measure();
					}

					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.fix();
					}
				}

				pause_effects(state, to_destroy, controlled_anchor, items);
			}
		}

		if (is_animated) {
			queue_micro_task(() => {
				if (to_animate === undefined) return;
				for (item of to_animate) {
					item.a?.apply();
				}
			});
		}

		/** @type {Effect} */ (active_effect).first = state.first && state.first.e;
		/** @type {Effect} */ (active_effect).last = prev && prev.e;
	}

	/**
	 * @param {EachItem} item
	 * @param {any} value
	 * @param {number} index
	 * @param {number} type
	 * @returns {void}
	 */
	function update_item(item, value, index, type) {
		if ((type & EACH_ITEM_REACTIVE) !== 0) {
			internal_set(item.v, value);
		}

		if ((type & EACH_INDEX_REACTIVE) !== 0) {
			internal_set(/** @type {Value<number>} */ (item.i), index);
		} else {
			item.i = index;
		}
	}

	/**
	 * @template V
	 * @param {Node} anchor
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 * @param {V} value
	 * @param {unknown} key
	 * @param {number} index
	 * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>, collection: () => V[]) => void} render_fn
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @returns {EachItem}
	 */
	function create_item(
		anchor,
		state,
		prev,
		next,
		value,
		key,
		index,
		render_fn,
		flags,
		get_collection
	) {
		var reactive = (flags & EACH_ITEM_REACTIVE) !== 0;
		var mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;

		var v = reactive ? (mutable ? mutable_source(value, false, false) : source(value)) : value;
		var i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);

		if (DEV && reactive) {
			// For tracing purposes, we need to link the source signal we create with the
			// collection + index so that tracing works as intended
			/** @type {Value} */ (v).trace = () => {
				var collection_index = typeof i === 'number' ? index : i.v;
				// eslint-disable-next-line @typescript-eslint/no-unused-expressions
				get_collection()[collection_index];
			};
		}

		/** @type {EachItem} */
		var item = {
			i,
			v,
			k: key,
			a: null,
			// @ts-expect-error
			e: null,
			prev,
			next
		};

		try {
			item.e = branch(() => render_fn(anchor, v, i, get_collection), hydrating);

			item.e.prev = prev && prev.e;
			item.e.next = next && next.e;

			if (prev === null) {
				state.first = item;
			} else {
				prev.next = item;
				prev.e.next = item.e;
			}

			if (next !== null) {
				next.prev = item;
				next.e.prev = item.e;
			}

			return item;
		} finally {
		}
	}

	/**
	 * @param {EachItem} item
	 * @param {EachItem | null} next
	 * @param {Text | Element | Comment} anchor
	 */
	function move(item, next, anchor) {
		var end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;

		var dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;
		var node = /** @type {TemplateNode} */ (item.e.nodes_start);

		while (node !== end) {
			var next_node = /** @type {TemplateNode} */ (get_next_sibling(node));
			dest.before(node);
			node = next_node;
		}
	}

	/**
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 */
	function link(state, prev, next) {
		if (prev === null) {
			state.first = next;
		} else {
			prev.next = next;
			prev.e.next = next && next.e;
		}

		if (next !== null) {
			next.prev = prev;
			next.e.prev = prev && prev.e;
		}
	}

	const whitespace = [...' \t\n\r\f\u00a0\u000b\ufeff'];

	/**
	 * @param {any} value
	 * @param {string | null} [hash]
	 * @param {Record<string, boolean>} [directives]
	 * @returns {string | null}
	 */
	function to_class(value, hash, directives) {
		var classname = value == null ? '' : '' + value;

		if (hash) {
			classname = classname ? classname + ' ' + hash : hash;
		}

		if (directives) {
			for (var key in directives) {
				if (directives[key]) {
					classname = classname ? classname + ' ' + key : key;
				} else if (classname.length) {
					var len = key.length;
					var a = 0;

					while ((a = classname.indexOf(key, a)) >= 0) {
						var b = a + len;

						if (
							(a === 0 || whitespace.includes(classname[a - 1])) &&
							(b === classname.length || whitespace.includes(classname[b]))
						) {
							classname = (a === 0 ? '' : classname.substring(0, a)) + classname.substring(b + 1);
						} else {
							a = b;
						}
					}
				}
			}
		}

		return classname === '' ? null : classname;
	}

	/**
	 *
	 * @param {Record<string,any>} styles
	 * @param {boolean} important
	 */
	function append_styles(styles, important = false) {
		var separator = important ? ' !important;' : ';';
		var css = '';

		for (var key in styles) {
			var value = styles[key];
			if (value != null && value !== '') {
				css += ' ' + key + ': ' + value + separator;
			}
		}

		return css;
	}

	/**
	 * @param {string} name
	 * @returns {string}
	 */
	function to_css_name(name) {
		if (name[0] !== '-' || name[1] !== '-') {
			return name.toLowerCase();
		}
		return name;
	}

	/**
	 * @param {any} value
	 * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [styles]
	 * @returns {string | null}
	 */
	function to_style(value, styles) {
		if (styles) {
			var new_style = '';

			/** @type {Record<string,any> | undefined} */
			var normal_styles;

			/** @type {Record<string,any> | undefined} */
			var important_styles;

			if (Array.isArray(styles)) {
				normal_styles = styles[0];
				important_styles = styles[1];
			} else {
				normal_styles = styles;
			}

			if (value) {
				value = String(value)
					.replaceAll(/\s*\/\*.*?\*\/\s*/g, '')
					.trim();

				/** @type {boolean | '"' | "'"} */
				var in_str = false;
				var in_apo = 0;
				var in_comment = false;

				var reserved_names = [];

				if (normal_styles) {
					reserved_names.push(...Object.keys(normal_styles).map(to_css_name));
				}
				if (important_styles) {
					reserved_names.push(...Object.keys(important_styles).map(to_css_name));
				}

				var start_index = 0;
				var name_index = -1;

				const len = value.length;
				for (var i = 0; i < len; i++) {
					var c = value[i];

					if (in_comment) {
						if (c === '/' && value[i - 1] === '*') {
							in_comment = false;
						}
					} else if (in_str) {
						if (in_str === c) {
							in_str = false;
						}
					} else if (c === '/' && value[i + 1] === '*') {
						in_comment = true;
					} else if (c === '"' || c === "'") {
						in_str = c;
					} else if (c === '(') {
						in_apo++;
					} else if (c === ')') {
						in_apo--;
					}

					if (!in_comment && in_str === false && in_apo === 0) {
						if (c === ':' && name_index === -1) {
							name_index = i;
						} else if (c === ';' || i === len - 1) {
							if (name_index !== -1) {
								var name = to_css_name(value.substring(start_index, name_index).trim());

								if (!reserved_names.includes(name)) {
									if (c !== ';') {
										i++;
									}

									var property = value.substring(start_index, i).trim();
									new_style += ' ' + property + ';';
								}
							}

							start_index = i + 1;
							name_index = -1;
						}
					}
				}
			}

			if (normal_styles) {
				new_style += append_styles(normal_styles);
			}

			if (important_styles) {
				new_style += append_styles(important_styles, true);
			}

			new_style = new_style.trim();
			return new_style === '' ? null : new_style;
		}

		return value == null ? null : String(value);
	}

	/**
	 * @param {Element} dom
	 * @param {boolean | number} is_html
	 * @param {string | null} value
	 * @param {string} [hash]
	 * @param {Record<string, any>} [prev_classes]
	 * @param {Record<string, any>} [next_classes]
	 * @returns {Record<string, boolean> | undefined}
	 */
	function set_class(dom, is_html, value, hash, prev_classes, next_classes) {
		// @ts-expect-error need to add __className to patched prototype
		var prev = dom.__className;

		if (
			prev !== value ||
			prev === undefined // for edge case of `class={undefined}`
		) {
			var next_class_name = to_class(value, hash, next_classes);

			{
				// Removing the attribute when the value is only an empty string causes
				// performance issues vs simply making the className an empty string. So
				// we should only remove the class if the value is nullish
				// and there no hash/directives :
				if (next_class_name == null) {
					dom.removeAttribute('class');
				} else if (is_html) {
					dom.className = next_class_name;
				} else {
					dom.setAttribute('class', next_class_name);
				}
			}

			// @ts-expect-error need to add __className to patched prototype
			dom.__className = value;
		} else if (next_classes && prev_classes !== next_classes) {
			for (var key in next_classes) {
				var is_present = !!next_classes[key];

				if (prev_classes == null || is_present !== !!prev_classes[key]) {
					dom.classList.toggle(key, is_present);
				}
			}
		}

		return next_classes;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} dom
	 * @param {Record<string, any>} prev
	 * @param {Record<string, any>} next
	 * @param {string} [priority]
	 */
	function update_styles(dom, prev = {}, next, priority) {
		for (var key in next) {
			var value = next[key];

			if (prev[key] !== value) {
				if (next[key] == null) {
					dom.style.removeProperty(key);
				} else {
					dom.style.setProperty(key, value, priority);
				}
			}
		}
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} dom
	 * @param {string | null} value
	 * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [prev_styles]
	 * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [next_styles]
	 */
	function set_style(dom, value, prev_styles, next_styles) {
		// @ts-expect-error
		var prev = dom.__style;

		if (prev !== value) {
			var next_style_attr = to_style(value, next_styles);

			{
				if (next_style_attr == null) {
					dom.removeAttribute('style');
				} else {
					dom.style.cssText = next_style_attr;
				}
			}

			// @ts-expect-error
			dom.__style = value;
		} else if (next_styles) {
			if (Array.isArray(next_styles)) {
				update_styles(dom, prev_styles?.[0], next_styles[0]);
				update_styles(dom, prev_styles?.[1], next_styles[1], 'important');
			} else {
				update_styles(dom, prev_styles, next_styles);
			}
		}

		return next_styles;
	}

	/** @import { Derived, Source } from './types.js' */

	/**
	 * The proxy handler for spread props. Handles the incoming array of props
	 * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps
	 * them so that the whole thing is passed to the component as the `$$props` argument.
	 * @template {Record<string | symbol, unknown>} T
	 * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}
	 */
	const spread_props_handler = {
		get(target, key) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				if (typeof p === 'object' && p !== null && key in p) return p[key];
			}
		},
		set(target, key, value) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				const desc = get_descriptor(p, key);
				if (desc && desc.set) {
					desc.set(value);
					return true;
				}
			}
			return false;
		},
		getOwnPropertyDescriptor(target, key) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				if (typeof p === 'object' && p !== null && key in p) {
					const descriptor = get_descriptor(p, key);
					if (descriptor && !descriptor.configurable) {
						// Prevent a "Non-configurability Report Error": The target is an array, it does
						// not actually contain this property. If it is now described as non-configurable,
						// the proxy throws a validation error. Setting it to true avoids that.
						descriptor.configurable = true;
					}
					return descriptor;
				}
			}
		},
		has(target, key) {
			// To prevent a false positive `is_entry_props` in the `prop` function
			if (key === STATE_SYMBOL || key === LEGACY_PROPS) return false;

			for (let p of target.props) {
				if (is_function(p)) p = p();
				if (p != null && key in p) return true;
			}

			return false;
		},
		ownKeys(target) {
			/** @type {Array<string | symbol>} */
			const keys = [];

			for (let p of target.props) {
				if (is_function(p)) p = p();
				if (!p) continue;

				for (const key in p) {
					if (!keys.includes(key)) keys.push(key);
				}

				for (const key of Object.getOwnPropertySymbols(p)) {
					if (!keys.includes(key)) keys.push(key);
				}
			}

			return keys;
		}
	};

	/**
	 * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props
	 * @returns {any}
	 */
	function spread_props(...props) {
		return new Proxy({ props }, spread_props_handler);
	}

	/** @import { ComponentConstructorOptions, ComponentType, SvelteComponent, Component } from 'svelte' */

	/**
	 * Runs the given function once immediately on the server, and works like `$effect.pre` on the client.
	 *
	 * @deprecated Use this only as a temporary solution to migrate your component code to Svelte 5.
	 * @param {() => void | (() => void)} fn
	 * @returns {void}
	 */
	function run(fn) {
		user_pre_effect(() => {
			fn();
			var effect = /** @type {import('#client').Effect} */ (active_effect);
			// If the effect is immediately made dirty again, mark it as maybe dirty to emulate legacy behaviour
			if ((effect.f & DIRTY) !== 0) {
				let filename = "a file (we can't know which one)";
				if (DEV) {
					// @ts-ignore
					filename = dev_current_component_function?.[FILENAME] ?? filename;
				}
				legacy_recursive_reactive_block(filename);
				set_signal_status(effect, MAYBE_DIRTY);
			}
		});
	}

	/**
	 * @param {string} method
	 * @param  {...any} objects
	 */
	function log_if_contains_state(method, ...objects) {
		untrack(() => {
			try {
				let has_state = false;
				const transformed = [];

				for (const obj of objects) {
					if (obj && typeof obj === 'object' && STATE_SYMBOL in obj) {
						transformed.push(snapshot(obj, true));
						has_state = true;
					} else {
						transformed.push(obj);
					}
				}

				if (has_state) {
					console_log_state(method);

					// eslint-disable-next-line no-console
					console.log('%c[snapshot]', 'color: grey', ...transformed);
				}
			} catch {}
		});

		return objects;
	}

	const PACKET_TYPES = Object.create(null); // no Map = no polyfill
	PACKET_TYPES["open"] = "0";
	PACKET_TYPES["close"] = "1";
	PACKET_TYPES["ping"] = "2";
	PACKET_TYPES["pong"] = "3";
	PACKET_TYPES["message"] = "4";
	PACKET_TYPES["upgrade"] = "5";
	PACKET_TYPES["noop"] = "6";
	const PACKET_TYPES_REVERSE = Object.create(null);
	Object.keys(PACKET_TYPES).forEach((key) => {
	    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
	});
	const ERROR_PACKET = { type: "error", data: "parser error" };

	const withNativeBlob$1 = typeof Blob === "function" ||
	    (typeof Blob !== "undefined" &&
	        Object.prototype.toString.call(Blob) === "[object BlobConstructor]");
	const withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
	// ArrayBuffer.isView method is not defined in IE10
	const isView$1 = (obj) => {
	    return typeof ArrayBuffer.isView === "function"
	        ? ArrayBuffer.isView(obj)
	        : obj && obj.buffer instanceof ArrayBuffer;
	};
	const encodePacket = ({ type, data }, supportsBinary, callback) => {
	    if (withNativeBlob$1 && data instanceof Blob) {
	        if (supportsBinary) {
	            return callback(data);
	        }
	        else {
	            return encodeBlobAsBase64(data, callback);
	        }
	    }
	    else if (withNativeArrayBuffer$2 &&
	        (data instanceof ArrayBuffer || isView$1(data))) {
	        if (supportsBinary) {
	            return callback(data);
	        }
	        else {
	            return encodeBlobAsBase64(new Blob([data]), callback);
	        }
	    }
	    // plain string
	    return callback(PACKET_TYPES[type] + (data || ""));
	};
	const encodeBlobAsBase64 = (data, callback) => {
	    const fileReader = new FileReader();
	    fileReader.onload = function () {
	        const content = fileReader.result.split(",")[1];
	        callback("b" + (content || ""));
	    };
	    return fileReader.readAsDataURL(data);
	};
	function toArray(data) {
	    if (data instanceof Uint8Array) {
	        return data;
	    }
	    else if (data instanceof ArrayBuffer) {
	        return new Uint8Array(data);
	    }
	    else {
	        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
	    }
	}
	let TEXT_ENCODER;
	function encodePacketToBinary(packet, callback) {
	    if (withNativeBlob$1 && packet.data instanceof Blob) {
	        return packet.data.arrayBuffer().then(toArray).then(callback);
	    }
	    else if (withNativeArrayBuffer$2 &&
	        (packet.data instanceof ArrayBuffer || isView$1(packet.data))) {
	        return callback(toArray(packet.data));
	    }
	    encodePacket(packet, false, (encoded) => {
	        if (!TEXT_ENCODER) {
	            TEXT_ENCODER = new TextEncoder();
	        }
	        callback(TEXT_ENCODER.encode(encoded));
	    });
	}

	// imported from https://github.com/socketio/base64-arraybuffer
	const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	// Use a lookup table to find the index.
	const lookup$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
	for (let i = 0; i < chars.length; i++) {
	    lookup$1[chars.charCodeAt(i)] = i;
	}
	const decode$1 = (base64) => {
	    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
	    if (base64[base64.length - 1] === '=') {
	        bufferLength--;
	        if (base64[base64.length - 2] === '=') {
	            bufferLength--;
	        }
	    }
	    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
	    for (i = 0; i < len; i += 4) {
	        encoded1 = lookup$1[base64.charCodeAt(i)];
	        encoded2 = lookup$1[base64.charCodeAt(i + 1)];
	        encoded3 = lookup$1[base64.charCodeAt(i + 2)];
	        encoded4 = lookup$1[base64.charCodeAt(i + 3)];
	        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
	        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
	        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
	    }
	    return arraybuffer;
	};

	const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
	const decodePacket = (encodedPacket, binaryType) => {
	    if (typeof encodedPacket !== "string") {
	        return {
	            type: "message",
	            data: mapBinary(encodedPacket, binaryType),
	        };
	    }
	    const type = encodedPacket.charAt(0);
	    if (type === "b") {
	        return {
	            type: "message",
	            data: decodeBase64Packet(encodedPacket.substring(1), binaryType),
	        };
	    }
	    const packetType = PACKET_TYPES_REVERSE[type];
	    if (!packetType) {
	        return ERROR_PACKET;
	    }
	    return encodedPacket.length > 1
	        ? {
	            type: PACKET_TYPES_REVERSE[type],
	            data: encodedPacket.substring(1),
	        }
	        : {
	            type: PACKET_TYPES_REVERSE[type],
	        };
	};
	const decodeBase64Packet = (data, binaryType) => {
	    if (withNativeArrayBuffer$1) {
	        const decoded = decode$1(data);
	        return mapBinary(decoded, binaryType);
	    }
	    else {
	        return { base64: true, data }; // fallback for old browsers
	    }
	};
	const mapBinary = (data, binaryType) => {
	    switch (binaryType) {
	        case "blob":
	            if (data instanceof Blob) {
	                // from WebSocket + binaryType "blob"
	                return data;
	            }
	            else {
	                // from HTTP long-polling or WebTransport
	                return new Blob([data]);
	            }
	        case "arraybuffer":
	        default:
	            if (data instanceof ArrayBuffer) {
	                // from HTTP long-polling (base64) or WebSocket + binaryType "arraybuffer"
	                return data;
	            }
	            else {
	                // from WebTransport (Uint8Array)
	                return data.buffer;
	            }
	    }
	};

	const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
	const encodePayload = (packets, callback) => {
	    // some packets may be added to the array while encoding, so the initial length must be saved
	    const length = packets.length;
	    const encodedPackets = new Array(length);
	    let count = 0;
	    packets.forEach((packet, i) => {
	        // force base64 encoding for binary packets
	        encodePacket(packet, false, (encodedPacket) => {
	            encodedPackets[i] = encodedPacket;
	            if (++count === length) {
	                callback(encodedPackets.join(SEPARATOR));
	            }
	        });
	    });
	};
	const decodePayload = (encodedPayload, binaryType) => {
	    const encodedPackets = encodedPayload.split(SEPARATOR);
	    const packets = [];
	    for (let i = 0; i < encodedPackets.length; i++) {
	        const decodedPacket = decodePacket(encodedPackets[i], binaryType);
	        packets.push(decodedPacket);
	        if (decodedPacket.type === "error") {
	            break;
	        }
	    }
	    return packets;
	};
	function createPacketEncoderStream() {
	    return new TransformStream({
	        transform(packet, controller) {
	            encodePacketToBinary(packet, (encodedPacket) => {
	                const payloadLength = encodedPacket.length;
	                let header;
	                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length
	                if (payloadLength < 126) {
	                    header = new Uint8Array(1);
	                    new DataView(header.buffer).setUint8(0, payloadLength);
	                }
	                else if (payloadLength < 65536) {
	                    header = new Uint8Array(3);
	                    const view = new DataView(header.buffer);
	                    view.setUint8(0, 126);
	                    view.setUint16(1, payloadLength);
	                }
	                else {
	                    header = new Uint8Array(9);
	                    const view = new DataView(header.buffer);
	                    view.setUint8(0, 127);
	                    view.setBigUint64(1, BigInt(payloadLength));
	                }
	                // first bit indicates whether the payload is plain text (0) or binary (1)
	                if (packet.data && typeof packet.data !== "string") {
	                    header[0] |= 0x80;
	                }
	                controller.enqueue(header);
	                controller.enqueue(encodedPacket);
	            });
	        },
	    });
	}
	let TEXT_DECODER;
	function totalLength(chunks) {
	    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
	}
	function concatChunks(chunks, size) {
	    if (chunks[0].length === size) {
	        return chunks.shift();
	    }
	    const buffer = new Uint8Array(size);
	    let j = 0;
	    for (let i = 0; i < size; i++) {
	        buffer[i] = chunks[0][j++];
	        if (j === chunks[0].length) {
	            chunks.shift();
	            j = 0;
	        }
	    }
	    if (chunks.length && j < chunks[0].length) {
	        chunks[0] = chunks[0].slice(j);
	    }
	    return buffer;
	}
	function createPacketDecoderStream(maxPayload, binaryType) {
	    if (!TEXT_DECODER) {
	        TEXT_DECODER = new TextDecoder();
	    }
	    const chunks = [];
	    let state = 0 /* State.READ_HEADER */;
	    let expectedLength = -1;
	    let isBinary = false;
	    return new TransformStream({
	        transform(chunk, controller) {
	            chunks.push(chunk);
	            while (true) {
	                if (state === 0 /* State.READ_HEADER */) {
	                    if (totalLength(chunks) < 1) {
	                        break;
	                    }
	                    const header = concatChunks(chunks, 1);
	                    isBinary = (header[0] & 0x80) === 0x80;
	                    expectedLength = header[0] & 0x7f;
	                    if (expectedLength < 126) {
	                        state = 3 /* State.READ_PAYLOAD */;
	                    }
	                    else if (expectedLength === 126) {
	                        state = 1 /* State.READ_EXTENDED_LENGTH_16 */;
	                    }
	                    else {
	                        state = 2 /* State.READ_EXTENDED_LENGTH_64 */;
	                    }
	                }
	                else if (state === 1 /* State.READ_EXTENDED_LENGTH_16 */) {
	                    if (totalLength(chunks) < 2) {
	                        break;
	                    }
	                    const headerArray = concatChunks(chunks, 2);
	                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
	                    state = 3 /* State.READ_PAYLOAD */;
	                }
	                else if (state === 2 /* State.READ_EXTENDED_LENGTH_64 */) {
	                    if (totalLength(chunks) < 8) {
	                        break;
	                    }
	                    const headerArray = concatChunks(chunks, 8);
	                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
	                    const n = view.getUint32(0);
	                    if (n > Math.pow(2, 53 - 32) - 1) {
	                        // the maximum safe integer in JavaScript is 2^53 - 1
	                        controller.enqueue(ERROR_PACKET);
	                        break;
	                    }
	                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
	                    state = 3 /* State.READ_PAYLOAD */;
	                }
	                else {
	                    if (totalLength(chunks) < expectedLength) {
	                        break;
	                    }
	                    const data = concatChunks(chunks, expectedLength);
	                    controller.enqueue(decodePacket(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
	                    state = 0 /* State.READ_HEADER */;
	                }
	                if (expectedLength === 0 || expectedLength > maxPayload) {
	                    controller.enqueue(ERROR_PACKET);
	                    break;
	                }
	            }
	        },
	    });
	}
	const protocol$1 = 4;

	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */

	function Emitter(obj) {
	  if (obj) return mixin(obj);
	}

	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */

	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}

	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
	    .push(fn);
	  return this;
	};

	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.once = function(event, fn){
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }

	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};

	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};

	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }

	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;

	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }

	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }

	  // Remove event specific arrays for event types that no
	  // one is subscribed for to avoid memory leak.
	  if (callbacks.length === 0) {
	    delete this._callbacks['$' + event];
	  }

	  return this;
	};

	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */

	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};

	  var args = new Array(arguments.length - 1)
	    , callbacks = this._callbacks['$' + event];

	  for (var i = 1; i < arguments.length; i++) {
	    args[i - 1] = arguments[i];
	  }

	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }

	  return this;
	};

	// alias used for reserved events (protected method)
	Emitter.prototype.emitReserved = Emitter.prototype.emit;

	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */

	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};

	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */

	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};

	const nextTick = (() => {
	    const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
	    if (isPromiseAvailable) {
	        return (cb) => Promise.resolve().then(cb);
	    }
	    else {
	        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
	    }
	})();
	const globalThisShim = (() => {
	    if (typeof self !== "undefined") {
	        return self;
	    }
	    else if (typeof window !== "undefined") {
	        return window;
	    }
	    else {
	        return Function("return this")();
	    }
	})();
	const defaultBinaryType = "arraybuffer";
	function createCookieJar() { }

	function pick(obj, ...attr) {
	    return attr.reduce((acc, k) => {
	        if (obj.hasOwnProperty(k)) {
	            acc[k] = obj[k];
	        }
	        return acc;
	    }, {});
	}
	// Keep a reference to the real timeout functions so they can be used when overridden
	const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
	const NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
	function installTimerFunctions(obj, opts) {
	    if (opts.useNativeTimers) {
	        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
	        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
	    }
	    else {
	        obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
	        obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
	    }
	}
	// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)
	const BASE64_OVERHEAD = 1.33;
	// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9
	function byteLength(obj) {
	    if (typeof obj === "string") {
	        return utf8Length(obj);
	    }
	    // arraybuffer or blob
	    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
	}
	function utf8Length(str) {
	    let c = 0, length = 0;
	    for (let i = 0, l = str.length; i < l; i++) {
	        c = str.charCodeAt(i);
	        if (c < 0x80) {
	            length += 1;
	        }
	        else if (c < 0x800) {
	            length += 2;
	        }
	        else if (c < 0xd800 || c >= 0xe000) {
	            length += 3;
	        }
	        else {
	            i++;
	            length += 4;
	        }
	    }
	    return length;
	}
	/**
	 * Generates a random 8-characters string.
	 */
	function randomString() {
	    return (Date.now().toString(36).substring(3) +
	        Math.random().toString(36).substring(2, 5));
	}

	// imported from https://github.com/galkn/querystring
	/**
	 * Compiles a querystring
	 * Returns string representation of the object
	 *
	 * @param {Object}
	 * @api private
	 */
	function encode(obj) {
	    let str = '';
	    for (let i in obj) {
	        if (obj.hasOwnProperty(i)) {
	            if (str.length)
	                str += '&';
	            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
	        }
	    }
	    return str;
	}
	/**
	 * Parses a simple querystring into an object
	 *
	 * @param {String} qs
	 * @api private
	 */
	function decode(qs) {
	    let qry = {};
	    let pairs = qs.split('&');
	    for (let i = 0, l = pairs.length; i < l; i++) {
	        let pair = pairs[i].split('=');
	        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
	    }
	    return qry;
	}

	class TransportError extends Error {
	    constructor(reason, description, context) {
	        super(reason);
	        this.description = description;
	        this.context = context;
	        this.type = "TransportError";
	    }
	}
	class Transport extends Emitter {
	    /**
	     * Transport abstract constructor.
	     *
	     * @param {Object} opts - options
	     * @protected
	     */
	    constructor(opts) {
	        super();
	        this.writable = false;
	        installTimerFunctions(this, opts);
	        this.opts = opts;
	        this.query = opts.query;
	        this.socket = opts.socket;
	        this.supportsBinary = !opts.forceBase64;
	    }
	    /**
	     * Emits an error.
	     *
	     * @param {String} reason
	     * @param description
	     * @param context - the error context
	     * @return {Transport} for chaining
	     * @protected
	     */
	    onError(reason, description, context) {
	        super.emitReserved("error", new TransportError(reason, description, context));
	        return this;
	    }
	    /**
	     * Opens the transport.
	     */
	    open() {
	        this.readyState = "opening";
	        this.doOpen();
	        return this;
	    }
	    /**
	     * Closes the transport.
	     */
	    close() {
	        if (this.readyState === "opening" || this.readyState === "open") {
	            this.doClose();
	            this.onClose();
	        }
	        return this;
	    }
	    /**
	     * Sends multiple packets.
	     *
	     * @param {Array} packets
	     */
	    send(packets) {
	        if (this.readyState === "open") {
	            this.write(packets);
	        }
	    }
	    /**
	     * Called upon open
	     *
	     * @protected
	     */
	    onOpen() {
	        this.readyState = "open";
	        this.writable = true;
	        super.emitReserved("open");
	    }
	    /**
	     * Called with data.
	     *
	     * @param {String} data
	     * @protected
	     */
	    onData(data) {
	        const packet = decodePacket(data, this.socket.binaryType);
	        this.onPacket(packet);
	    }
	    /**
	     * Called with a decoded packet.
	     *
	     * @protected
	     */
	    onPacket(packet) {
	        super.emitReserved("packet", packet);
	    }
	    /**
	     * Called upon close.
	     *
	     * @protected
	     */
	    onClose(details) {
	        this.readyState = "closed";
	        super.emitReserved("close", details);
	    }
	    /**
	     * Pauses the transport, in order not to lose packets during an upgrade.
	     *
	     * @param onPause
	     */
	    pause(onPause) { }
	    createUri(schema, query = {}) {
	        return (schema +
	            "://" +
	            this._hostname() +
	            this._port() +
	            this.opts.path +
	            this._query(query));
	    }
	    _hostname() {
	        const hostname = this.opts.hostname;
	        return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
	    }
	    _port() {
	        if (this.opts.port &&
	            ((this.opts.secure && Number(this.opts.port !== 443)) ||
	                (!this.opts.secure && Number(this.opts.port) !== 80))) {
	            return ":" + this.opts.port;
	        }
	        else {
	            return "";
	        }
	    }
	    _query(query) {
	        const encodedQuery = encode(query);
	        return encodedQuery.length ? "?" + encodedQuery : "";
	    }
	}

	class Polling extends Transport {
	    constructor() {
	        super(...arguments);
	        this._polling = false;
	    }
	    get name() {
	        return "polling";
	    }
	    /**
	     * Opens the socket (triggers polling). We write a PING message to determine
	     * when the transport is open.
	     *
	     * @protected
	     */
	    doOpen() {
	        this._poll();
	    }
	    /**
	     * Pauses polling.
	     *
	     * @param {Function} onPause - callback upon buffers are flushed and transport is paused
	     * @package
	     */
	    pause(onPause) {
	        this.readyState = "pausing";
	        const pause = () => {
	            this.readyState = "paused";
	            onPause();
	        };
	        if (this._polling || !this.writable) {
	            let total = 0;
	            if (this._polling) {
	                total++;
	                this.once("pollComplete", function () {
	                    --total || pause();
	                });
	            }
	            if (!this.writable) {
	                total++;
	                this.once("drain", function () {
	                    --total || pause();
	                });
	            }
	        }
	        else {
	            pause();
	        }
	    }
	    /**
	     * Starts polling cycle.
	     *
	     * @private
	     */
	    _poll() {
	        this._polling = true;
	        this.doPoll();
	        this.emitReserved("poll");
	    }
	    /**
	     * Overloads onData to detect payloads.
	     *
	     * @protected
	     */
	    onData(data) {
	        const callback = (packet) => {
	            // if its the first message we consider the transport open
	            if ("opening" === this.readyState && packet.type === "open") {
	                this.onOpen();
	            }
	            // if its a close packet, we close the ongoing requests
	            if ("close" === packet.type) {
	                this.onClose({ description: "transport closed by the server" });
	                return false;
	            }
	            // otherwise bypass onData and handle the message
	            this.onPacket(packet);
	        };
	        // decode payload
	        decodePayload(data, this.socket.binaryType).forEach(callback);
	        // if an event did not trigger closing
	        if ("closed" !== this.readyState) {
	            // if we got data we're not polling
	            this._polling = false;
	            this.emitReserved("pollComplete");
	            if ("open" === this.readyState) {
	                this._poll();
	            }
	        }
	    }
	    /**
	     * For polling, send a close packet.
	     *
	     * @protected
	     */
	    doClose() {
	        const close = () => {
	            this.write([{ type: "close" }]);
	        };
	        if ("open" === this.readyState) {
	            close();
	        }
	        else {
	            // in case we're trying to close while
	            // handshaking is in progress (GH-164)
	            this.once("open", close);
	        }
	    }
	    /**
	     * Writes a packets payload.
	     *
	     * @param {Array} packets - data packets
	     * @protected
	     */
	    write(packets) {
	        this.writable = false;
	        encodePayload(packets, (data) => {
	            this.doWrite(data, () => {
	                this.writable = true;
	                this.emitReserved("drain");
	            });
	        });
	    }
	    /**
	     * Generates uri for connection.
	     *
	     * @private
	     */
	    uri() {
	        const schema = this.opts.secure ? "https" : "http";
	        const query = this.query || {};
	        // cache busting is forced
	        if (false !== this.opts.timestampRequests) {
	            query[this.opts.timestampParam] = randomString();
	        }
	        if (!this.supportsBinary && !query.sid) {
	            query.b64 = 1;
	        }
	        return this.createUri(schema, query);
	    }
	}

	// imported from https://github.com/component/has-cors
	let value = false;
	try {
	    value = typeof XMLHttpRequest !== 'undefined' &&
	        'withCredentials' in new XMLHttpRequest();
	}
	catch (err) {
	    // if XMLHttp support is disabled in IE then it will throw
	    // when trying to create
	}
	const hasCORS = value;

	function empty() { }
	class BaseXHR extends Polling {
	    /**
	     * XHR Polling constructor.
	     *
	     * @param {Object} opts
	     * @package
	     */
	    constructor(opts) {
	        super(opts);
	        if (typeof location !== "undefined") {
	            const isSSL = "https:" === location.protocol;
	            let port = location.port;
	            // some user agents have empty `location.port`
	            if (!port) {
	                port = isSSL ? "443" : "80";
	            }
	            this.xd =
	                (typeof location !== "undefined" &&
	                    opts.hostname !== location.hostname) ||
	                    port !== opts.port;
	        }
	    }
	    /**
	     * Sends data.
	     *
	     * @param {String} data to send.
	     * @param {Function} called upon flush.
	     * @private
	     */
	    doWrite(data, fn) {
	        const req = this.request({
	            method: "POST",
	            data: data,
	        });
	        req.on("success", fn);
	        req.on("error", (xhrStatus, context) => {
	            this.onError("xhr post error", xhrStatus, context);
	        });
	    }
	    /**
	     * Starts a poll cycle.
	     *
	     * @private
	     */
	    doPoll() {
	        const req = this.request();
	        req.on("data", this.onData.bind(this));
	        req.on("error", (xhrStatus, context) => {
	            this.onError("xhr poll error", xhrStatus, context);
	        });
	        this.pollXhr = req;
	    }
	}
	class Request extends Emitter {
	    /**
	     * Request constructor
	     *
	     * @param {Object} options
	     * @package
	     */
	    constructor(createRequest, uri, opts) {
	        super();
	        this.createRequest = createRequest;
	        installTimerFunctions(this, opts);
	        this._opts = opts;
	        this._method = opts.method || "GET";
	        this._uri = uri;
	        this._data = undefined !== opts.data ? opts.data : null;
	        this._create();
	    }
	    /**
	     * Creates the XHR object and sends the request.
	     *
	     * @private
	     */
	    _create() {
	        var _a;
	        const opts = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
	        opts.xdomain = !!this._opts.xd;
	        const xhr = (this._xhr = this.createRequest(opts));
	        try {
	            xhr.open(this._method, this._uri, true);
	            try {
	                if (this._opts.extraHeaders) {
	                    // @ts-ignore
	                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
	                    for (let i in this._opts.extraHeaders) {
	                        if (this._opts.extraHeaders.hasOwnProperty(i)) {
	                            xhr.setRequestHeader(i, this._opts.extraHeaders[i]);
	                        }
	                    }
	                }
	            }
	            catch (e) { }
	            if ("POST" === this._method) {
	                try {
	                    xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
	                }
	                catch (e) { }
	            }
	            try {
	                xhr.setRequestHeader("Accept", "*/*");
	            }
	            catch (e) { }
	            (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
	            // ie6 check
	            if ("withCredentials" in xhr) {
	                xhr.withCredentials = this._opts.withCredentials;
	            }
	            if (this._opts.requestTimeout) {
	                xhr.timeout = this._opts.requestTimeout;
	            }
	            xhr.onreadystatechange = () => {
	                var _a;
	                if (xhr.readyState === 3) {
	                    (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(
	                    // @ts-ignore
	                    xhr.getResponseHeader("set-cookie"));
	                }
	                if (4 !== xhr.readyState)
	                    return;
	                if (200 === xhr.status || 1223 === xhr.status) {
	                    this._onLoad();
	                }
	                else {
	                    // make sure the `error` event handler that's user-set
	                    // does not throw in the same tick and gets caught here
	                    this.setTimeoutFn(() => {
	                        this._onError(typeof xhr.status === "number" ? xhr.status : 0);
	                    }, 0);
	                }
	            };
	            xhr.send(this._data);
	        }
	        catch (e) {
	            // Need to defer since .create() is called directly from the constructor
	            // and thus the 'error' event can only be only bound *after* this exception
	            // occurs.  Therefore, also, we cannot throw here at all.
	            this.setTimeoutFn(() => {
	                this._onError(e);
	            }, 0);
	            return;
	        }
	        if (typeof document !== "undefined") {
	            this._index = Request.requestsCount++;
	            Request.requests[this._index] = this;
	        }
	    }
	    /**
	     * Called upon error.
	     *
	     * @private
	     */
	    _onError(err) {
	        this.emitReserved("error", err, this._xhr);
	        this._cleanup(true);
	    }
	    /**
	     * Cleans up house.
	     *
	     * @private
	     */
	    _cleanup(fromError) {
	        if ("undefined" === typeof this._xhr || null === this._xhr) {
	            return;
	        }
	        this._xhr.onreadystatechange = empty;
	        if (fromError) {
	            try {
	                this._xhr.abort();
	            }
	            catch (e) { }
	        }
	        if (typeof document !== "undefined") {
	            delete Request.requests[this._index];
	        }
	        this._xhr = null;
	    }
	    /**
	     * Called upon load.
	     *
	     * @private
	     */
	    _onLoad() {
	        const data = this._xhr.responseText;
	        if (data !== null) {
	            this.emitReserved("data", data);
	            this.emitReserved("success");
	            this._cleanup();
	        }
	    }
	    /**
	     * Aborts the request.
	     *
	     * @package
	     */
	    abort() {
	        this._cleanup();
	    }
	}
	Request.requestsCount = 0;
	Request.requests = {};
	/**
	 * Aborts pending requests when unloading the window. This is needed to prevent
	 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
	 * emitted.
	 */
	if (typeof document !== "undefined") {
	    // @ts-ignore
	    if (typeof attachEvent === "function") {
	        // @ts-ignore
	        attachEvent("onunload", unloadHandler);
	    }
	    else if (typeof addEventListener === "function") {
	        const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
	        addEventListener(terminationEvent, unloadHandler, false);
	    }
	}
	function unloadHandler() {
	    for (let i in Request.requests) {
	        if (Request.requests.hasOwnProperty(i)) {
	            Request.requests[i].abort();
	        }
	    }
	}
	const hasXHR2 = (function () {
	    const xhr = newRequest({
	        xdomain: false,
	    });
	    return xhr && xhr.responseType !== null;
	})();
	/**
	 * HTTP long-polling based on the built-in `XMLHttpRequest` object.
	 *
	 * Usage: browser
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
	 */
	class XHR extends BaseXHR {
	    constructor(opts) {
	        super(opts);
	        const forceBase64 = opts && opts.forceBase64;
	        this.supportsBinary = hasXHR2 && !forceBase64;
	    }
	    request(opts = {}) {
	        Object.assign(opts, { xd: this.xd }, this.opts);
	        return new Request(newRequest, this.uri(), opts);
	    }
	}
	function newRequest(opts) {
	    const xdomain = opts.xdomain;
	    // XMLHttpRequest can be disabled on IE
	    try {
	        if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
	            return new XMLHttpRequest();
	        }
	    }
	    catch (e) { }
	    if (!xdomain) {
	        try {
	            return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
	        }
	        catch (e) { }
	    }
	}

	// detect ReactNative environment
	const isReactNative = typeof navigator !== "undefined" &&
	    typeof navigator.product === "string" &&
	    navigator.product.toLowerCase() === "reactnative";
	class BaseWS extends Transport {
	    get name() {
	        return "websocket";
	    }
	    doOpen() {
	        const uri = this.uri();
	        const protocols = this.opts.protocols;
	        // React Native only supports the 'headers' option, and will print a warning if anything else is passed
	        const opts = isReactNative
	            ? {}
	            : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
	        if (this.opts.extraHeaders) {
	            opts.headers = this.opts.extraHeaders;
	        }
	        try {
	            this.ws = this.createSocket(uri, protocols, opts);
	        }
	        catch (err) {
	            return this.emitReserved("error", err);
	        }
	        this.ws.binaryType = this.socket.binaryType;
	        this.addEventListeners();
	    }
	    /**
	     * Adds event listeners to the socket
	     *
	     * @private
	     */
	    addEventListeners() {
	        this.ws.onopen = () => {
	            if (this.opts.autoUnref) {
	                this.ws._socket.unref();
	            }
	            this.onOpen();
	        };
	        this.ws.onclose = (closeEvent) => this.onClose({
	            description: "websocket connection closed",
	            context: closeEvent,
	        });
	        this.ws.onmessage = (ev) => this.onData(ev.data);
	        this.ws.onerror = (e) => this.onError("websocket error", e);
	    }
	    write(packets) {
	        this.writable = false;
	        // encodePacket efficient as it uses WS framing
	        // no need for encodePayload
	        for (let i = 0; i < packets.length; i++) {
	            const packet = packets[i];
	            const lastPacket = i === packets.length - 1;
	            encodePacket(packet, this.supportsBinary, (data) => {
	                // Sometimes the websocket has already been closed but the browser didn't
	                // have a chance of informing us about it yet, in that case send will
	                // throw an error
	                try {
	                    this.doWrite(packet, data);
	                }
	                catch (e) {
	                }
	                if (lastPacket) {
	                    // fake drain
	                    // defer to next tick to allow Socket to clear writeBuffer
	                    nextTick(() => {
	                        this.writable = true;
	                        this.emitReserved("drain");
	                    }, this.setTimeoutFn);
	                }
	            });
	        }
	    }
	    doClose() {
	        if (typeof this.ws !== "undefined") {
	            this.ws.onerror = () => { };
	            this.ws.close();
	            this.ws = null;
	        }
	    }
	    /**
	     * Generates uri for connection.
	     *
	     * @private
	     */
	    uri() {
	        const schema = this.opts.secure ? "wss" : "ws";
	        const query = this.query || {};
	        // append timestamp to URI
	        if (this.opts.timestampRequests) {
	            query[this.opts.timestampParam] = randomString();
	        }
	        // communicate binary support capabilities
	        if (!this.supportsBinary) {
	            query.b64 = 1;
	        }
	        return this.createUri(schema, query);
	    }
	}
	const WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
	/**
	 * WebSocket transport based on the built-in `WebSocket` object.
	 *
	 * Usage: browser, Node.js (since v21), Deno, Bun
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
	 * @see https://caniuse.com/mdn-api_websocket
	 * @see https://nodejs.org/api/globals.html#websocket
	 */
	class WS extends BaseWS {
	    createSocket(uri, protocols, opts) {
	        return !isReactNative
	            ? protocols
	                ? new WebSocketCtor(uri, protocols)
	                : new WebSocketCtor(uri)
	            : new WebSocketCtor(uri, protocols, opts);
	    }
	    doWrite(_packet, data) {
	        this.ws.send(data);
	    }
	}

	/**
	 * WebTransport transport based on the built-in `WebTransport` object.
	 *
	 * Usage: browser, Node.js (with the `@fails-components/webtransport` package)
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebTransport
	 * @see https://caniuse.com/webtransport
	 */
	class WT extends Transport {
	    get name() {
	        return "webtransport";
	    }
	    doOpen() {
	        try {
	            // @ts-ignore
	            this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
	        }
	        catch (err) {
	            return this.emitReserved("error", err);
	        }
	        this._transport.closed
	            .then(() => {
	            this.onClose();
	        })
	            .catch((err) => {
	            this.onError("webtransport error", err);
	        });
	        // note: we could have used async/await, but that would require some additional polyfills
	        this._transport.ready.then(() => {
	            this._transport.createBidirectionalStream().then((stream) => {
	                const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
	                const reader = stream.readable.pipeThrough(decoderStream).getReader();
	                const encoderStream = createPacketEncoderStream();
	                encoderStream.readable.pipeTo(stream.writable);
	                this._writer = encoderStream.writable.getWriter();
	                const read = () => {
	                    reader
	                        .read()
	                        .then(({ done, value }) => {
	                        if (done) {
	                            return;
	                        }
	                        this.onPacket(value);
	                        read();
	                    })
	                        .catch((err) => {
	                    });
	                };
	                read();
	                const packet = { type: "open" };
	                if (this.query.sid) {
	                    packet.data = `{"sid":"${this.query.sid}"}`;
	                }
	                this._writer.write(packet).then(() => this.onOpen());
	            });
	        });
	    }
	    write(packets) {
	        this.writable = false;
	        for (let i = 0; i < packets.length; i++) {
	            const packet = packets[i];
	            const lastPacket = i === packets.length - 1;
	            this._writer.write(packet).then(() => {
	                if (lastPacket) {
	                    nextTick(() => {
	                        this.writable = true;
	                        this.emitReserved("drain");
	                    }, this.setTimeoutFn);
	                }
	            });
	        }
	    }
	    doClose() {
	        var _a;
	        (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();
	    }
	}

	const transports = {
	    websocket: WS,
	    webtransport: WT,
	    polling: XHR,
	};

	// imported from https://github.com/galkn/parseuri
	/**
	 * Parses a URI
	 *
	 * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.
	 *
	 * See:
	 * - https://developer.mozilla.org/en-US/docs/Web/API/URL
	 * - https://caniuse.com/url
	 * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B
	 *
	 * History of the parse() method:
	 * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c
	 * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3
	 * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242
	 *
	 * @author Steven Levithan <stevenlevithan.com> (MIT license)
	 * @api private
	 */
	const re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
	const parts = [
	    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
	];
	function parse(str) {
	    if (str.length > 8000) {
	        throw "URI too long";
	    }
	    const src = str, b = str.indexOf('['), e = str.indexOf(']');
	    if (b != -1 && e != -1) {
	        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
	    }
	    let m = re.exec(str || ''), uri = {}, i = 14;
	    while (i--) {
	        uri[parts[i]] = m[i] || '';
	    }
	    if (b != -1 && e != -1) {
	        uri.source = src;
	        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
	        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
	        uri.ipv6uri = true;
	    }
	    uri.pathNames = pathNames(uri, uri['path']);
	    uri.queryKey = queryKey(uri, uri['query']);
	    return uri;
	}
	function pathNames(obj, path) {
	    const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
	    if (path.slice(0, 1) == '/' || path.length === 0) {
	        names.splice(0, 1);
	    }
	    if (path.slice(-1) == '/') {
	        names.splice(names.length - 1, 1);
	    }
	    return names;
	}
	function queryKey(uri, query) {
	    const data = {};
	    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
	        if ($1) {
	            data[$1] = $2;
	        }
	    });
	    return data;
	}

	const withEventListeners = typeof addEventListener === "function" &&
	    typeof removeEventListener === "function";
	const OFFLINE_EVENT_LISTENERS = [];
	if (withEventListeners) {
	    // within a ServiceWorker, any event handler for the 'offline' event must be added on the initial evaluation of the
	    // script, so we create one single event listener here which will forward the event to the socket instances
	    addEventListener("offline", () => {
	        OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());
	    }, false);
	}
	/**
	 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
	 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
	 *
	 * This class comes without upgrade mechanism, which means that it will keep the first low-level transport that
	 * successfully establishes the connection.
	 *
	 * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
	 *
	 * @example
	 * import { SocketWithoutUpgrade, WebSocket } from "engine.io-client";
	 *
	 * const socket = new SocketWithoutUpgrade({
	 *   transports: [WebSocket]
	 * });
	 *
	 * socket.on("open", () => {
	 *   socket.send("hello");
	 * });
	 *
	 * @see SocketWithUpgrade
	 * @see Socket
	 */
	class SocketWithoutUpgrade extends Emitter {
	    /**
	     * Socket constructor.
	     *
	     * @param {String|Object} uri - uri or options
	     * @param {Object} opts - options
	     */
	    constructor(uri, opts) {
	        super();
	        this.binaryType = defaultBinaryType;
	        this.writeBuffer = [];
	        this._prevBufferLen = 0;
	        this._pingInterval = -1;
	        this._pingTimeout = -1;
	        this._maxPayload = -1;
	        /**
	         * The expiration timestamp of the {@link _pingTimeoutTimer} object is tracked, in case the timer is throttled and the
	         * callback is not fired on time. This can happen for example when a laptop is suspended or when a phone is locked.
	         */
	        this._pingTimeoutTime = Infinity;
	        if (uri && "object" === typeof uri) {
	            opts = uri;
	            uri = null;
	        }
	        if (uri) {
	            const parsedUri = parse(uri);
	            opts.hostname = parsedUri.host;
	            opts.secure =
	                parsedUri.protocol === "https" || parsedUri.protocol === "wss";
	            opts.port = parsedUri.port;
	            if (parsedUri.query)
	                opts.query = parsedUri.query;
	        }
	        else if (opts.host) {
	            opts.hostname = parse(opts.host).host;
	        }
	        installTimerFunctions(this, opts);
	        this.secure =
	            null != opts.secure
	                ? opts.secure
	                : typeof location !== "undefined" && "https:" === location.protocol;
	        if (opts.hostname && !opts.port) {
	            // if no port is specified manually, use the protocol default
	            opts.port = this.secure ? "443" : "80";
	        }
	        this.hostname =
	            opts.hostname ||
	                (typeof location !== "undefined" ? location.hostname : "localhost");
	        this.port =
	            opts.port ||
	                (typeof location !== "undefined" && location.port
	                    ? location.port
	                    : this.secure
	                        ? "443"
	                        : "80");
	        this.transports = [];
	        this._transportsByName = {};
	        opts.transports.forEach((t) => {
	            const transportName = t.prototype.name;
	            this.transports.push(transportName);
	            this._transportsByName[transportName] = t;
	        });
	        this.opts = Object.assign({
	            path: "/engine.io",
	            agent: false,
	            withCredentials: false,
	            upgrade: true,
	            timestampParam: "t",
	            rememberUpgrade: false,
	            addTrailingSlash: true,
	            rejectUnauthorized: true,
	            perMessageDeflate: {
	                threshold: 1024,
	            },
	            transportOptions: {},
	            closeOnBeforeunload: false,
	        }, opts);
	        this.opts.path =
	            this.opts.path.replace(/\/$/, "") +
	                (this.opts.addTrailingSlash ? "/" : "");
	        if (typeof this.opts.query === "string") {
	            this.opts.query = decode(this.opts.query);
	        }
	        if (withEventListeners) {
	            if (this.opts.closeOnBeforeunload) {
	                // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
	                // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
	                // closed/reloaded)
	                this._beforeunloadEventListener = () => {
	                    if (this.transport) {
	                        // silently close the transport
	                        this.transport.removeAllListeners();
	                        this.transport.close();
	                    }
	                };
	                addEventListener("beforeunload", this._beforeunloadEventListener, false);
	            }
	            if (this.hostname !== "localhost") {
	                this._offlineEventListener = () => {
	                    this._onClose("transport close", {
	                        description: "network connection lost",
	                    });
	                };
	                OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
	            }
	        }
	        if (this.opts.withCredentials) {
	            this._cookieJar = createCookieJar();
	        }
	        this._open();
	    }
	    /**
	     * Creates transport of the given type.
	     *
	     * @param {String} name - transport name
	     * @return {Transport}
	     * @private
	     */
	    createTransport(name) {
	        const query = Object.assign({}, this.opts.query);
	        // append engine.io protocol identifier
	        query.EIO = protocol$1;
	        // transport name
	        query.transport = name;
	        // session id if we already have one
	        if (this.id)
	            query.sid = this.id;
	        const opts = Object.assign({}, this.opts, {
	            query,
	            socket: this,
	            hostname: this.hostname,
	            secure: this.secure,
	            port: this.port,
	        }, this.opts.transportOptions[name]);
	        return new this._transportsByName[name](opts);
	    }
	    /**
	     * Initializes transport to use and starts probe.
	     *
	     * @private
	     */
	    _open() {
	        if (this.transports.length === 0) {
	            // Emit error on next tick so it can be listened to
	            this.setTimeoutFn(() => {
	                this.emitReserved("error", "No transports available");
	            }, 0);
	            return;
	        }
	        const transportName = this.opts.rememberUpgrade &&
	            SocketWithoutUpgrade.priorWebsocketSuccess &&
	            this.transports.indexOf("websocket") !== -1
	            ? "websocket"
	            : this.transports[0];
	        this.readyState = "opening";
	        const transport = this.createTransport(transportName);
	        transport.open();
	        this.setTransport(transport);
	    }
	    /**
	     * Sets the current transport. Disables the existing one (if any).
	     *
	     * @private
	     */
	    setTransport(transport) {
	        if (this.transport) {
	            this.transport.removeAllListeners();
	        }
	        // set up transport
	        this.transport = transport;
	        // set up transport listeners
	        transport
	            .on("drain", this._onDrain.bind(this))
	            .on("packet", this._onPacket.bind(this))
	            .on("error", this._onError.bind(this))
	            .on("close", (reason) => this._onClose("transport close", reason));
	    }
	    /**
	     * Called when connection is deemed open.
	     *
	     * @private
	     */
	    onOpen() {
	        this.readyState = "open";
	        SocketWithoutUpgrade.priorWebsocketSuccess =
	            "websocket" === this.transport.name;
	        this.emitReserved("open");
	        this.flush();
	    }
	    /**
	     * Handles a packet.
	     *
	     * @private
	     */
	    _onPacket(packet) {
	        if ("opening" === this.readyState ||
	            "open" === this.readyState ||
	            "closing" === this.readyState) {
	            this.emitReserved("packet", packet);
	            // Socket is live - any packet counts
	            this.emitReserved("heartbeat");
	            switch (packet.type) {
	                case "open":
	                    this.onHandshake(JSON.parse(packet.data));
	                    break;
	                case "ping":
	                    this._sendPacket("pong");
	                    this.emitReserved("ping");
	                    this.emitReserved("pong");
	                    this._resetPingTimeout();
	                    break;
	                case "error":
	                    const err = new Error("server error");
	                    // @ts-ignore
	                    err.code = packet.data;
	                    this._onError(err);
	                    break;
	                case "message":
	                    this.emitReserved("data", packet.data);
	                    this.emitReserved("message", packet.data);
	                    break;
	            }
	        }
	    }
	    /**
	     * Called upon handshake completion.
	     *
	     * @param {Object} data - handshake obj
	     * @private
	     */
	    onHandshake(data) {
	        this.emitReserved("handshake", data);
	        this.id = data.sid;
	        this.transport.query.sid = data.sid;
	        this._pingInterval = data.pingInterval;
	        this._pingTimeout = data.pingTimeout;
	        this._maxPayload = data.maxPayload;
	        this.onOpen();
	        // In case open handler closes socket
	        if ("closed" === this.readyState)
	            return;
	        this._resetPingTimeout();
	    }
	    /**
	     * Sets and resets ping timeout timer based on server pings.
	     *
	     * @private
	     */
	    _resetPingTimeout() {
	        this.clearTimeoutFn(this._pingTimeoutTimer);
	        const delay = this._pingInterval + this._pingTimeout;
	        this._pingTimeoutTime = Date.now() + delay;
	        this._pingTimeoutTimer = this.setTimeoutFn(() => {
	            this._onClose("ping timeout");
	        }, delay);
	        if (this.opts.autoUnref) {
	            this._pingTimeoutTimer.unref();
	        }
	    }
	    /**
	     * Called on `drain` event
	     *
	     * @private
	     */
	    _onDrain() {
	        this.writeBuffer.splice(0, this._prevBufferLen);
	        // setting prevBufferLen = 0 is very important
	        // for example, when upgrading, upgrade packet is sent over,
	        // and a nonzero prevBufferLen could cause problems on `drain`
	        this._prevBufferLen = 0;
	        if (0 === this.writeBuffer.length) {
	            this.emitReserved("drain");
	        }
	        else {
	            this.flush();
	        }
	    }
	    /**
	     * Flush write buffers.
	     *
	     * @private
	     */
	    flush() {
	        if ("closed" !== this.readyState &&
	            this.transport.writable &&
	            !this.upgrading &&
	            this.writeBuffer.length) {
	            const packets = this._getWritablePackets();
	            this.transport.send(packets);
	            // keep track of current length of writeBuffer
	            // splice writeBuffer and callbackBuffer on `drain`
	            this._prevBufferLen = packets.length;
	            this.emitReserved("flush");
	        }
	    }
	    /**
	     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
	     * long-polling)
	     *
	     * @private
	     */
	    _getWritablePackets() {
	        const shouldCheckPayloadSize = this._maxPayload &&
	            this.transport.name === "polling" &&
	            this.writeBuffer.length > 1;
	        if (!shouldCheckPayloadSize) {
	            return this.writeBuffer;
	        }
	        let payloadSize = 1; // first packet type
	        for (let i = 0; i < this.writeBuffer.length; i++) {
	            const data = this.writeBuffer[i].data;
	            if (data) {
	                payloadSize += byteLength(data);
	            }
	            if (i > 0 && payloadSize > this._maxPayload) {
	                return this.writeBuffer.slice(0, i);
	            }
	            payloadSize += 2; // separator + packet type
	        }
	        return this.writeBuffer;
	    }
	    /**
	     * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
	     *
	     * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
	     * `write()` method then the message would not be buffered by the Socket.IO client.
	     *
	     * @return {boolean}
	     * @private
	     */
	    /* private */ _hasPingExpired() {
	        if (!this._pingTimeoutTime)
	            return true;
	        const hasExpired = Date.now() > this._pingTimeoutTime;
	        if (hasExpired) {
	            this._pingTimeoutTime = 0;
	            nextTick(() => {
	                this._onClose("ping timeout");
	            }, this.setTimeoutFn);
	        }
	        return hasExpired;
	    }
	    /**
	     * Sends a message.
	     *
	     * @param {String} msg - message.
	     * @param {Object} options.
	     * @param {Function} fn - callback function.
	     * @return {Socket} for chaining.
	     */
	    write(msg, options, fn) {
	        this._sendPacket("message", msg, options, fn);
	        return this;
	    }
	    /**
	     * Sends a message. Alias of {@link Socket#write}.
	     *
	     * @param {String} msg - message.
	     * @param {Object} options.
	     * @param {Function} fn - callback function.
	     * @return {Socket} for chaining.
	     */
	    send(msg, options, fn) {
	        this._sendPacket("message", msg, options, fn);
	        return this;
	    }
	    /**
	     * Sends a packet.
	     *
	     * @param {String} type: packet type.
	     * @param {String} data.
	     * @param {Object} options.
	     * @param {Function} fn - callback function.
	     * @private
	     */
	    _sendPacket(type, data, options, fn) {
	        if ("function" === typeof data) {
	            fn = data;
	            data = undefined;
	        }
	        if ("function" === typeof options) {
	            fn = options;
	            options = null;
	        }
	        if ("closing" === this.readyState || "closed" === this.readyState) {
	            return;
	        }
	        options = options || {};
	        options.compress = false !== options.compress;
	        const packet = {
	            type: type,
	            data: data,
	            options: options,
	        };
	        this.emitReserved("packetCreate", packet);
	        this.writeBuffer.push(packet);
	        if (fn)
	            this.once("flush", fn);
	        this.flush();
	    }
	    /**
	     * Closes the connection.
	     */
	    close() {
	        const close = () => {
	            this._onClose("forced close");
	            this.transport.close();
	        };
	        const cleanupAndClose = () => {
	            this.off("upgrade", cleanupAndClose);
	            this.off("upgradeError", cleanupAndClose);
	            close();
	        };
	        const waitForUpgrade = () => {
	            // wait for upgrade to finish since we can't send packets while pausing a transport
	            this.once("upgrade", cleanupAndClose);
	            this.once("upgradeError", cleanupAndClose);
	        };
	        if ("opening" === this.readyState || "open" === this.readyState) {
	            this.readyState = "closing";
	            if (this.writeBuffer.length) {
	                this.once("drain", () => {
	                    if (this.upgrading) {
	                        waitForUpgrade();
	                    }
	                    else {
	                        close();
	                    }
	                });
	            }
	            else if (this.upgrading) {
	                waitForUpgrade();
	            }
	            else {
	                close();
	            }
	        }
	        return this;
	    }
	    /**
	     * Called upon transport error
	     *
	     * @private
	     */
	    _onError(err) {
	        SocketWithoutUpgrade.priorWebsocketSuccess = false;
	        if (this.opts.tryAllTransports &&
	            this.transports.length > 1 &&
	            this.readyState === "opening") {
	            this.transports.shift();
	            return this._open();
	        }
	        this.emitReserved("error", err);
	        this._onClose("transport error", err);
	    }
	    /**
	     * Called upon transport close.
	     *
	     * @private
	     */
	    _onClose(reason, description) {
	        if ("opening" === this.readyState ||
	            "open" === this.readyState ||
	            "closing" === this.readyState) {
	            // clear timers
	            this.clearTimeoutFn(this._pingTimeoutTimer);
	            // stop event from firing again for transport
	            this.transport.removeAllListeners("close");
	            // ensure transport won't stay open
	            this.transport.close();
	            // ignore further transport communication
	            this.transport.removeAllListeners();
	            if (withEventListeners) {
	                if (this._beforeunloadEventListener) {
	                    removeEventListener("beforeunload", this._beforeunloadEventListener, false);
	                }
	                if (this._offlineEventListener) {
	                    const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
	                    if (i !== -1) {
	                        OFFLINE_EVENT_LISTENERS.splice(i, 1);
	                    }
	                }
	            }
	            // set ready state
	            this.readyState = "closed";
	            // clear session id
	            this.id = null;
	            // emit close event
	            this.emitReserved("close", reason, description);
	            // clean buffers after, so users can still
	            // grab the buffers on `close` event
	            this.writeBuffer = [];
	            this._prevBufferLen = 0;
	        }
	    }
	}
	SocketWithoutUpgrade.protocol = protocol$1;
	/**
	 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
	 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
	 *
	 * This class comes with an upgrade mechanism, which means that once the connection is established with the first
	 * low-level transport, it will try to upgrade to a better transport.
	 *
	 * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
	 *
	 * @example
	 * import { SocketWithUpgrade, WebSocket } from "engine.io-client";
	 *
	 * const socket = new SocketWithUpgrade({
	 *   transports: [WebSocket]
	 * });
	 *
	 * socket.on("open", () => {
	 *   socket.send("hello");
	 * });
	 *
	 * @see SocketWithoutUpgrade
	 * @see Socket
	 */
	class SocketWithUpgrade extends SocketWithoutUpgrade {
	    constructor() {
	        super(...arguments);
	        this._upgrades = [];
	    }
	    onOpen() {
	        super.onOpen();
	        if ("open" === this.readyState && this.opts.upgrade) {
	            for (let i = 0; i < this._upgrades.length; i++) {
	                this._probe(this._upgrades[i]);
	            }
	        }
	    }
	    /**
	     * Probes a transport.
	     *
	     * @param {String} name - transport name
	     * @private
	     */
	    _probe(name) {
	        let transport = this.createTransport(name);
	        let failed = false;
	        SocketWithoutUpgrade.priorWebsocketSuccess = false;
	        const onTransportOpen = () => {
	            if (failed)
	                return;
	            transport.send([{ type: "ping", data: "probe" }]);
	            transport.once("packet", (msg) => {
	                if (failed)
	                    return;
	                if ("pong" === msg.type && "probe" === msg.data) {
	                    this.upgrading = true;
	                    this.emitReserved("upgrading", transport);
	                    if (!transport)
	                        return;
	                    SocketWithoutUpgrade.priorWebsocketSuccess =
	                        "websocket" === transport.name;
	                    this.transport.pause(() => {
	                        if (failed)
	                            return;
	                        if ("closed" === this.readyState)
	                            return;
	                        cleanup();
	                        this.setTransport(transport);
	                        transport.send([{ type: "upgrade" }]);
	                        this.emitReserved("upgrade", transport);
	                        transport = null;
	                        this.upgrading = false;
	                        this.flush();
	                    });
	                }
	                else {
	                    const err = new Error("probe error");
	                    // @ts-ignore
	                    err.transport = transport.name;
	                    this.emitReserved("upgradeError", err);
	                }
	            });
	        };
	        function freezeTransport() {
	            if (failed)
	                return;
	            // Any callback called by transport should be ignored since now
	            failed = true;
	            cleanup();
	            transport.close();
	            transport = null;
	        }
	        // Handle any error that happens while probing
	        const onerror = (err) => {
	            const error = new Error("probe error: " + err);
	            // @ts-ignore
	            error.transport = transport.name;
	            freezeTransport();
	            this.emitReserved("upgradeError", error);
	        };
	        function onTransportClose() {
	            onerror("transport closed");
	        }
	        // When the socket is closed while we're probing
	        function onclose() {
	            onerror("socket closed");
	        }
	        // When the socket is upgraded while we're probing
	        function onupgrade(to) {
	            if (transport && to.name !== transport.name) {
	                freezeTransport();
	            }
	        }
	        // Remove all listeners on the transport and on self
	        const cleanup = () => {
	            transport.removeListener("open", onTransportOpen);
	            transport.removeListener("error", onerror);
	            transport.removeListener("close", onTransportClose);
	            this.off("close", onclose);
	            this.off("upgrading", onupgrade);
	        };
	        transport.once("open", onTransportOpen);
	        transport.once("error", onerror);
	        transport.once("close", onTransportClose);
	        this.once("close", onclose);
	        this.once("upgrading", onupgrade);
	        if (this._upgrades.indexOf("webtransport") !== -1 &&
	            name !== "webtransport") {
	            // favor WebTransport
	            this.setTimeoutFn(() => {
	                if (!failed) {
	                    transport.open();
	                }
	            }, 200);
	        }
	        else {
	            transport.open();
	        }
	    }
	    onHandshake(data) {
	        this._upgrades = this._filterUpgrades(data.upgrades);
	        super.onHandshake(data);
	    }
	    /**
	     * Filters upgrades, returning only those matching client transports.
	     *
	     * @param {Array} upgrades - server upgrades
	     * @private
	     */
	    _filterUpgrades(upgrades) {
	        const filteredUpgrades = [];
	        for (let i = 0; i < upgrades.length; i++) {
	            if (~this.transports.indexOf(upgrades[i]))
	                filteredUpgrades.push(upgrades[i]);
	        }
	        return filteredUpgrades;
	    }
	}
	/**
	 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
	 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
	 *
	 * This class comes with an upgrade mechanism, which means that once the connection is established with the first
	 * low-level transport, it will try to upgrade to a better transport.
	 *
	 * @example
	 * import { Socket } from "engine.io-client";
	 *
	 * const socket = new Socket();
	 *
	 * socket.on("open", () => {
	 *   socket.send("hello");
	 * });
	 *
	 * @see SocketWithoutUpgrade
	 * @see SocketWithUpgrade
	 */
	let Socket$1 = class Socket extends SocketWithUpgrade {
	    constructor(uri, opts = {}) {
	        const o = typeof uri === "object" ? uri : opts;
	        if (!o.transports ||
	            (o.transports && typeof o.transports[0] === "string")) {
	            o.transports = (o.transports || ["polling", "websocket", "webtransport"])
	                .map((transportName) => transports[transportName])
	                .filter((t) => !!t);
	        }
	        super(uri, o);
	    }
	};

	/**
	 * URL parser.
	 *
	 * @param uri - url
	 * @param path - the request path of the connection
	 * @param loc - An object meant to mimic window.location.
	 *        Defaults to window.location.
	 * @public
	 */
	function url(uri, path = "", loc) {
	    let obj = uri;
	    // default to window.location
	    loc = loc || (typeof location !== "undefined" && location);
	    if (null == uri)
	        uri = loc.protocol + "//" + loc.host;
	    // relative path support
	    if (typeof uri === "string") {
	        if ("/" === uri.charAt(0)) {
	            if ("/" === uri.charAt(1)) {
	                uri = loc.protocol + uri;
	            }
	            else {
	                uri = loc.host + uri;
	            }
	        }
	        if (!/^(https?|wss?):\/\//.test(uri)) {
	            if ("undefined" !== typeof loc) {
	                uri = loc.protocol + "//" + uri;
	            }
	            else {
	                uri = "https://" + uri;
	            }
	        }
	        // parse
	        obj = parse(uri);
	    }
	    // make sure we treat `localhost:80` and `localhost` equally
	    if (!obj.port) {
	        if (/^(http|ws)$/.test(obj.protocol)) {
	            obj.port = "80";
	        }
	        else if (/^(http|ws)s$/.test(obj.protocol)) {
	            obj.port = "443";
	        }
	    }
	    obj.path = obj.path || "/";
	    const ipv6 = obj.host.indexOf(":") !== -1;
	    const host = ipv6 ? "[" + obj.host + "]" : obj.host;
	    // define unique id
	    obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
	    // define href
	    obj.href =
	        obj.protocol +
	            "://" +
	            host +
	            (loc && loc.port === obj.port ? "" : ":" + obj.port);
	    return obj;
	}

	const withNativeArrayBuffer = typeof ArrayBuffer === "function";
	const isView = (obj) => {
	    return typeof ArrayBuffer.isView === "function"
	        ? ArrayBuffer.isView(obj)
	        : obj.buffer instanceof ArrayBuffer;
	};
	const toString = Object.prototype.toString;
	const withNativeBlob = typeof Blob === "function" ||
	    (typeof Blob !== "undefined" &&
	        toString.call(Blob) === "[object BlobConstructor]");
	const withNativeFile = typeof File === "function" ||
	    (typeof File !== "undefined" &&
	        toString.call(File) === "[object FileConstructor]");
	/**
	 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
	 *
	 * @private
	 */
	function isBinary(obj) {
	    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||
	        (withNativeBlob && obj instanceof Blob) ||
	        (withNativeFile && obj instanceof File));
	}
	function hasBinary(obj, toJSON) {
	    if (!obj || typeof obj !== "object") {
	        return false;
	    }
	    if (Array.isArray(obj)) {
	        for (let i = 0, l = obj.length; i < l; i++) {
	            if (hasBinary(obj[i])) {
	                return true;
	            }
	        }
	        return false;
	    }
	    if (isBinary(obj)) {
	        return true;
	    }
	    if (obj.toJSON &&
	        typeof obj.toJSON === "function" &&
	        arguments.length === 1) {
	        return hasBinary(obj.toJSON(), true);
	    }
	    for (const key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
	            return true;
	        }
	    }
	    return false;
	}

	/**
	 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @public
	 */
	function deconstructPacket(packet) {
	    const buffers = [];
	    const packetData = packet.data;
	    const pack = packet;
	    pack.data = _deconstructPacket(packetData, buffers);
	    pack.attachments = buffers.length; // number of binary 'attachments'
	    return { packet: pack, buffers: buffers };
	}
	function _deconstructPacket(data, buffers) {
	    if (!data)
	        return data;
	    if (isBinary(data)) {
	        const placeholder = { _placeholder: true, num: buffers.length };
	        buffers.push(data);
	        return placeholder;
	    }
	    else if (Array.isArray(data)) {
	        const newData = new Array(data.length);
	        for (let i = 0; i < data.length; i++) {
	            newData[i] = _deconstructPacket(data[i], buffers);
	        }
	        return newData;
	    }
	    else if (typeof data === "object" && !(data instanceof Date)) {
	        const newData = {};
	        for (const key in data) {
	            if (Object.prototype.hasOwnProperty.call(data, key)) {
	                newData[key] = _deconstructPacket(data[key], buffers);
	            }
	        }
	        return newData;
	    }
	    return data;
	}
	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @public
	 */
	function reconstructPacket(packet, buffers) {
	    packet.data = _reconstructPacket(packet.data, buffers);
	    delete packet.attachments; // no longer useful
	    return packet;
	}
	function _reconstructPacket(data, buffers) {
	    if (!data)
	        return data;
	    if (data && data._placeholder === true) {
	        const isIndexValid = typeof data.num === "number" &&
	            data.num >= 0 &&
	            data.num < buffers.length;
	        if (isIndexValid) {
	            return buffers[data.num]; // appropriate buffer (should be natural order anyway)
	        }
	        else {
	            throw new Error("illegal attachments");
	        }
	    }
	    else if (Array.isArray(data)) {
	        for (let i = 0; i < data.length; i++) {
	            data[i] = _reconstructPacket(data[i], buffers);
	        }
	    }
	    else if (typeof data === "object") {
	        for (const key in data) {
	            if (Object.prototype.hasOwnProperty.call(data, key)) {
	                data[key] = _reconstructPacket(data[key], buffers);
	            }
	        }
	    }
	    return data;
	}

	/**
	 * These strings must not be used as event names, as they have a special meaning.
	 */
	const RESERVED_EVENTS$1 = [
	    "connect",
	    "connect_error",
	    "disconnect",
	    "disconnecting",
	    "newListener",
	    "removeListener", // used by the Node.js EventEmitter
	];
	/**
	 * Protocol version.
	 *
	 * @public
	 */
	const protocol = 5;
	var PacketType;
	(function (PacketType) {
	    PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
	    PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
	    PacketType[PacketType["EVENT"] = 2] = "EVENT";
	    PacketType[PacketType["ACK"] = 3] = "ACK";
	    PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
	    PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
	    PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
	})(PacketType || (PacketType = {}));
	/**
	 * A socket.io Encoder instance
	 */
	class Encoder {
	    /**
	     * Encoder constructor
	     *
	     * @param {function} replacer - custom replacer to pass down to JSON.parse
	     */
	    constructor(replacer) {
	        this.replacer = replacer;
	    }
	    /**
	     * Encode a packet as a single string if non-binary, or as a
	     * buffer sequence, depending on packet type.
	     *
	     * @param {Object} obj - packet object
	     */
	    encode(obj) {
	        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
	            if (hasBinary(obj)) {
	                return this.encodeAsBinary({
	                    type: obj.type === PacketType.EVENT
	                        ? PacketType.BINARY_EVENT
	                        : PacketType.BINARY_ACK,
	                    nsp: obj.nsp,
	                    data: obj.data,
	                    id: obj.id,
	                });
	            }
	        }
	        return [this.encodeAsString(obj)];
	    }
	    /**
	     * Encode packet as string.
	     */
	    encodeAsString(obj) {
	        // first is type
	        let str = "" + obj.type;
	        // attachments if we have them
	        if (obj.type === PacketType.BINARY_EVENT ||
	            obj.type === PacketType.BINARY_ACK) {
	            str += obj.attachments + "-";
	        }
	        // if we have a namespace other than `/`
	        // we append it followed by a comma `,`
	        if (obj.nsp && "/" !== obj.nsp) {
	            str += obj.nsp + ",";
	        }
	        // immediately followed by the id
	        if (null != obj.id) {
	            str += obj.id;
	        }
	        // json data
	        if (null != obj.data) {
	            str += JSON.stringify(obj.data, this.replacer);
	        }
	        return str;
	    }
	    /**
	     * Encode packet as 'buffer sequence' by removing blobs, and
	     * deconstructing packet into object with placeholders and
	     * a list of buffers.
	     */
	    encodeAsBinary(obj) {
	        const deconstruction = deconstructPacket(obj);
	        const pack = this.encodeAsString(deconstruction.packet);
	        const buffers = deconstruction.buffers;
	        buffers.unshift(pack); // add packet info to beginning of data list
	        return buffers; // write all the buffers
	    }
	}
	// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript
	function isObject(value) {
	    return Object.prototype.toString.call(value) === "[object Object]";
	}
	/**
	 * A socket.io Decoder instance
	 *
	 * @return {Object} decoder
	 */
	class Decoder extends Emitter {
	    /**
	     * Decoder constructor
	     *
	     * @param {function} reviver - custom reviver to pass down to JSON.stringify
	     */
	    constructor(reviver) {
	        super();
	        this.reviver = reviver;
	    }
	    /**
	     * Decodes an encoded packet string into packet JSON.
	     *
	     * @param {String} obj - encoded packet
	     */
	    add(obj) {
	        let packet;
	        if (typeof obj === "string") {
	            if (this.reconstructor) {
	                throw new Error("got plaintext data when reconstructing a packet");
	            }
	            packet = this.decodeString(obj);
	            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
	            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
	                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
	                // binary packet's json
	                this.reconstructor = new BinaryReconstructor(packet);
	                // no attachments, labeled binary but no binary data to follow
	                if (packet.attachments === 0) {
	                    super.emitReserved("decoded", packet);
	                }
	            }
	            else {
	                // non-binary full packet
	                super.emitReserved("decoded", packet);
	            }
	        }
	        else if (isBinary(obj) || obj.base64) {
	            // raw binary data
	            if (!this.reconstructor) {
	                throw new Error("got binary data when not reconstructing a packet");
	            }
	            else {
	                packet = this.reconstructor.takeBinaryData(obj);
	                if (packet) {
	                    // received final buffer
	                    this.reconstructor = null;
	                    super.emitReserved("decoded", packet);
	                }
	            }
	        }
	        else {
	            throw new Error("Unknown type: " + obj);
	        }
	    }
	    /**
	     * Decode a packet String (JSON data)
	     *
	     * @param {String} str
	     * @return {Object} packet
	     */
	    decodeString(str) {
	        let i = 0;
	        // look up type
	        const p = {
	            type: Number(str.charAt(0)),
	        };
	        if (PacketType[p.type] === undefined) {
	            throw new Error("unknown packet type " + p.type);
	        }
	        // look up attachments if type binary
	        if (p.type === PacketType.BINARY_EVENT ||
	            p.type === PacketType.BINARY_ACK) {
	            const start = i + 1;
	            while (str.charAt(++i) !== "-" && i != str.length) { }
	            const buf = str.substring(start, i);
	            if (buf != Number(buf) || str.charAt(i) !== "-") {
	                throw new Error("Illegal attachments");
	            }
	            p.attachments = Number(buf);
	        }
	        // look up namespace (if any)
	        if ("/" === str.charAt(i + 1)) {
	            const start = i + 1;
	            while (++i) {
	                const c = str.charAt(i);
	                if ("," === c)
	                    break;
	                if (i === str.length)
	                    break;
	            }
	            p.nsp = str.substring(start, i);
	        }
	        else {
	            p.nsp = "/";
	        }
	        // look up id
	        const next = str.charAt(i + 1);
	        if ("" !== next && Number(next) == next) {
	            const start = i + 1;
	            while (++i) {
	                const c = str.charAt(i);
	                if (null == c || Number(c) != c) {
	                    --i;
	                    break;
	                }
	                if (i === str.length)
	                    break;
	            }
	            p.id = Number(str.substring(start, i + 1));
	        }
	        // look up json data
	        if (str.charAt(++i)) {
	            const payload = this.tryParse(str.substr(i));
	            if (Decoder.isPayloadValid(p.type, payload)) {
	                p.data = payload;
	            }
	            else {
	                throw new Error("invalid payload");
	            }
	        }
	        return p;
	    }
	    tryParse(str) {
	        try {
	            return JSON.parse(str, this.reviver);
	        }
	        catch (e) {
	            return false;
	        }
	    }
	    static isPayloadValid(type, payload) {
	        switch (type) {
	            case PacketType.CONNECT:
	                return isObject(payload);
	            case PacketType.DISCONNECT:
	                return payload === undefined;
	            case PacketType.CONNECT_ERROR:
	                return typeof payload === "string" || isObject(payload);
	            case PacketType.EVENT:
	            case PacketType.BINARY_EVENT:
	                return (Array.isArray(payload) &&
	                    (typeof payload[0] === "number" ||
	                        (typeof payload[0] === "string" &&
	                            RESERVED_EVENTS$1.indexOf(payload[0]) === -1)));
	            case PacketType.ACK:
	            case PacketType.BINARY_ACK:
	                return Array.isArray(payload);
	        }
	    }
	    /**
	     * Deallocates a parser's resources
	     */
	    destroy() {
	        if (this.reconstructor) {
	            this.reconstructor.finishedReconstruction();
	            this.reconstructor = null;
	        }
	    }
	}
	/**
	 * A manager of a binary event's 'buffer sequence'. Should
	 * be constructed whenever a packet of type BINARY_EVENT is
	 * decoded.
	 *
	 * @param {Object} packet
	 * @return {BinaryReconstructor} initialized reconstructor
	 */
	class BinaryReconstructor {
	    constructor(packet) {
	        this.packet = packet;
	        this.buffers = [];
	        this.reconPack = packet;
	    }
	    /**
	     * Method to be called when binary data received from connection
	     * after a BINARY_EVENT packet.
	     *
	     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	     * @return {null | Object} returns null if more binary data is expected or
	     *   a reconstructed packet object if all buffers have been received.
	     */
	    takeBinaryData(binData) {
	        this.buffers.push(binData);
	        if (this.buffers.length === this.reconPack.attachments) {
	            // done with buffer list
	            const packet = reconstructPacket(this.reconPack, this.buffers);
	            this.finishedReconstruction();
	            return packet;
	        }
	        return null;
	    }
	    /**
	     * Cleans up binary packet reconstruction variables.
	     */
	    finishedReconstruction() {
	        this.reconPack = null;
	        this.buffers = [];
	    }
	}

	var parser = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Decoder: Decoder,
		Encoder: Encoder,
		get PacketType () { return PacketType; },
		protocol: protocol
	});

	function on(obj, ev, fn) {
	    obj.on(ev, fn);
	    return function subDestroy() {
	        obj.off(ev, fn);
	    };
	}

	/**
	 * Internal events.
	 * These events can't be emitted by the user.
	 */
	const RESERVED_EVENTS = Object.freeze({
	    connect: 1,
	    connect_error: 1,
	    disconnect: 1,
	    disconnecting: 1,
	    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
	    newListener: 1,
	    removeListener: 1,
	});
	/**
	 * A Socket is the fundamental class for interacting with the server.
	 *
	 * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.
	 *
	 * @example
	 * const socket = io();
	 *
	 * socket.on("connect", () => {
	 *   console.log("connected");
	 * });
	 *
	 * // send an event to the server
	 * socket.emit("foo", "bar");
	 *
	 * socket.on("foobar", () => {
	 *   // an event was received from the server
	 * });
	 *
	 * // upon disconnection
	 * socket.on("disconnect", (reason) => {
	 *   console.log(`disconnected due to ${reason}`);
	 * });
	 */
	class Socket extends Emitter {
	    /**
	     * `Socket` constructor.
	     */
	    constructor(io, nsp, opts) {
	        super();
	        /**
	         * Whether the socket is currently connected to the server.
	         *
	         * @example
	         * const socket = io();
	         *
	         * socket.on("connect", () => {
	         *   console.log(socket.connected); // true
	         * });
	         *
	         * socket.on("disconnect", () => {
	         *   console.log(socket.connected); // false
	         * });
	         */
	        this.connected = false;
	        /**
	         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will
	         * be transmitted by the server.
	         */
	        this.recovered = false;
	        /**
	         * Buffer for packets received before the CONNECT packet
	         */
	        this.receiveBuffer = [];
	        /**
	         * Buffer for packets that will be sent once the socket is connected
	         */
	        this.sendBuffer = [];
	        /**
	         * The queue of packets to be sent with retry in case of failure.
	         *
	         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.
	         * @private
	         */
	        this._queue = [];
	        /**
	         * A sequence to generate the ID of the {@link QueuedPacket}.
	         * @private
	         */
	        this._queueSeq = 0;
	        this.ids = 0;
	        /**
	         * A map containing acknowledgement handlers.
	         *
	         * The `withError` attribute is used to differentiate handlers that accept an error as first argument:
	         *
	         * - `socket.emit("test", (err, value) => { ... })` with `ackTimeout` option
	         * - `socket.timeout(5000).emit("test", (err, value) => { ... })`
	         * - `const value = await socket.emitWithAck("test")`
	         *
	         * From those that don't:
	         *
	         * - `socket.emit("test", (value) => { ... });`
	         *
	         * In the first case, the handlers will be called with an error when:
	         *
	         * - the timeout is reached
	         * - the socket gets disconnected
	         *
	         * In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive
	         * an acknowledgement from the server.
	         *
	         * @private
	         */
	        this.acks = {};
	        this.flags = {};
	        this.io = io;
	        this.nsp = nsp;
	        if (opts && opts.auth) {
	            this.auth = opts.auth;
	        }
	        this._opts = Object.assign({}, opts);
	        if (this.io._autoConnect)
	            this.open();
	    }
	    /**
	     * Whether the socket is currently disconnected
	     *
	     * @example
	     * const socket = io();
	     *
	     * socket.on("connect", () => {
	     *   console.log(socket.disconnected); // false
	     * });
	     *
	     * socket.on("disconnect", () => {
	     *   console.log(socket.disconnected); // true
	     * });
	     */
	    get disconnected() {
	        return !this.connected;
	    }
	    /**
	     * Subscribe to open, close and packet events
	     *
	     * @private
	     */
	    subEvents() {
	        if (this.subs)
	            return;
	        const io = this.io;
	        this.subs = [
	            on(io, "open", this.onopen.bind(this)),
	            on(io, "packet", this.onpacket.bind(this)),
	            on(io, "error", this.onerror.bind(this)),
	            on(io, "close", this.onclose.bind(this)),
	        ];
	    }
	    /**
	     * Whether the Socket will try to reconnect when its Manager connects or reconnects.
	     *
	     * @example
	     * const socket = io();
	     *
	     * console.log(socket.active); // true
	     *
	     * socket.on("disconnect", (reason) => {
	     *   if (reason === "io server disconnect") {
	     *     // the disconnection was initiated by the server, you need to manually reconnect
	     *     console.log(socket.active); // false
	     *   }
	     *   // else the socket will automatically try to reconnect
	     *   console.log(socket.active); // true
	     * });
	     */
	    get active() {
	        return !!this.subs;
	    }
	    /**
	     * "Opens" the socket.
	     *
	     * @example
	     * const socket = io({
	     *   autoConnect: false
	     * });
	     *
	     * socket.connect();
	     */
	    connect() {
	        if (this.connected)
	            return this;
	        this.subEvents();
	        if (!this.io["_reconnecting"])
	            this.io.open(); // ensure open
	        if ("open" === this.io._readyState)
	            this.onopen();
	        return this;
	    }
	    /**
	     * Alias for {@link connect()}.
	     */
	    open() {
	        return this.connect();
	    }
	    /**
	     * Sends a `message` event.
	     *
	     * This method mimics the WebSocket.send() method.
	     *
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
	     *
	     * @example
	     * socket.send("hello");
	     *
	     * // this is equivalent to
	     * socket.emit("message", "hello");
	     *
	     * @return self
	     */
	    send(...args) {
	        args.unshift("message");
	        this.emit.apply(this, args);
	        return this;
	    }
	    /**
	     * Override `emit`.
	     * If the event is in `events`, it's emitted normally.
	     *
	     * @example
	     * socket.emit("hello", "world");
	     *
	     * // all serializable datastructures are supported (no need to call JSON.stringify)
	     * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
	     *
	     * // with an acknowledgement from the server
	     * socket.emit("hello", "world", (val) => {
	     *   // ...
	     * });
	     *
	     * @return self
	     */
	    emit(ev, ...args) {
	        var _a, _b, _c;
	        if (RESERVED_EVENTS.hasOwnProperty(ev)) {
	            throw new Error('"' + ev.toString() + '" is a reserved event name');
	        }
	        args.unshift(ev);
	        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
	            this._addToQueue(args);
	            return this;
	        }
	        const packet = {
	            type: PacketType.EVENT,
	            data: args,
	        };
	        packet.options = {};
	        packet.options.compress = this.flags.compress !== false;
	        // event ack callback
	        if ("function" === typeof args[args.length - 1]) {
	            const id = this.ids++;
	            const ack = args.pop();
	            this._registerAckCallback(id, ack);
	            packet.id = id;
	        }
	        const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;
	        const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());
	        const discardPacket = this.flags.volatile && !isTransportWritable;
	        if (discardPacket) ;
	        else if (isConnected) {
	            this.notifyOutgoingListeners(packet);
	            this.packet(packet);
	        }
	        else {
	            this.sendBuffer.push(packet);
	        }
	        this.flags = {};
	        return this;
	    }
	    /**
	     * @private
	     */
	    _registerAckCallback(id, ack) {
	        var _a;
	        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
	        if (timeout === undefined) {
	            this.acks[id] = ack;
	            return;
	        }
	        // @ts-ignore
	        const timer = this.io.setTimeoutFn(() => {
	            delete this.acks[id];
	            for (let i = 0; i < this.sendBuffer.length; i++) {
	                if (this.sendBuffer[i].id === id) {
	                    this.sendBuffer.splice(i, 1);
	                }
	            }
	            ack.call(this, new Error("operation has timed out"));
	        }, timeout);
	        const fn = (...args) => {
	            // @ts-ignore
	            this.io.clearTimeoutFn(timer);
	            ack.apply(this, args);
	        };
	        fn.withError = true;
	        this.acks[id] = fn;
	    }
	    /**
	     * Emits an event and waits for an acknowledgement
	     *
	     * @example
	     * // without timeout
	     * const response = await socket.emitWithAck("hello", "world");
	     *
	     * // with a specific timeout
	     * try {
	     *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
	     * } catch (err) {
	     *   // the server did not acknowledge the event in the given delay
	     * }
	     *
	     * @return a Promise that will be fulfilled when the server acknowledges the event
	     */
	    emitWithAck(ev, ...args) {
	        return new Promise((resolve, reject) => {
	            const fn = (arg1, arg2) => {
	                return arg1 ? reject(arg1) : resolve(arg2);
	            };
	            fn.withError = true;
	            args.push(fn);
	            this.emit(ev, ...args);
	        });
	    }
	    /**
	     * Add the packet to the queue.
	     * @param args
	     * @private
	     */
	    _addToQueue(args) {
	        let ack;
	        if (typeof args[args.length - 1] === "function") {
	            ack = args.pop();
	        }
	        const packet = {
	            id: this._queueSeq++,
	            tryCount: 0,
	            pending: false,
	            args,
	            flags: Object.assign({ fromQueue: true }, this.flags),
	        };
	        args.push((err, ...responseArgs) => {
	            if (packet !== this._queue[0]) {
	                // the packet has already been acknowledged
	                return;
	            }
	            const hasError = err !== null;
	            if (hasError) {
	                if (packet.tryCount > this._opts.retries) {
	                    this._queue.shift();
	                    if (ack) {
	                        ack(err);
	                    }
	                }
	            }
	            else {
	                this._queue.shift();
	                if (ack) {
	                    ack(null, ...responseArgs);
	                }
	            }
	            packet.pending = false;
	            return this._drainQueue();
	        });
	        this._queue.push(packet);
	        this._drainQueue();
	    }
	    /**
	     * Send the first packet of the queue, and wait for an acknowledgement from the server.
	     * @param force - whether to resend a packet that has not been acknowledged yet
	     *
	     * @private
	     */
	    _drainQueue(force = false) {
	        if (!this.connected || this._queue.length === 0) {
	            return;
	        }
	        const packet = this._queue[0];
	        if (packet.pending && !force) {
	            return;
	        }
	        packet.pending = true;
	        packet.tryCount++;
	        this.flags = packet.flags;
	        this.emit.apply(this, packet.args);
	    }
	    /**
	     * Sends a packet.
	     *
	     * @param packet
	     * @private
	     */
	    packet(packet) {
	        packet.nsp = this.nsp;
	        this.io._packet(packet);
	    }
	    /**
	     * Called upon engine `open`.
	     *
	     * @private
	     */
	    onopen() {
	        if (typeof this.auth == "function") {
	            this.auth((data) => {
	                this._sendConnectPacket(data);
	            });
	        }
	        else {
	            this._sendConnectPacket(this.auth);
	        }
	    }
	    /**
	     * Sends a CONNECT packet to initiate the Socket.IO session.
	     *
	     * @param data
	     * @private
	     */
	    _sendConnectPacket(data) {
	        this.packet({
	            type: PacketType.CONNECT,
	            data: this._pid
	                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data)
	                : data,
	        });
	    }
	    /**
	     * Called upon engine or manager `error`.
	     *
	     * @param err
	     * @private
	     */
	    onerror(err) {
	        if (!this.connected) {
	            this.emitReserved("connect_error", err);
	        }
	    }
	    /**
	     * Called upon engine `close`.
	     *
	     * @param reason
	     * @param description
	     * @private
	     */
	    onclose(reason, description) {
	        this.connected = false;
	        delete this.id;
	        this.emitReserved("disconnect", reason, description);
	        this._clearAcks();
	    }
	    /**
	     * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
	     * the server.
	     *
	     * @private
	     */
	    _clearAcks() {
	        Object.keys(this.acks).forEach((id) => {
	            const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
	            if (!isBuffered) {
	                // note: handlers that do not accept an error as first argument are ignored here
	                const ack = this.acks[id];
	                delete this.acks[id];
	                if (ack.withError) {
	                    ack.call(this, new Error("socket has been disconnected"));
	                }
	            }
	        });
	    }
	    /**
	     * Called with socket packet.
	     *
	     * @param packet
	     * @private
	     */
	    onpacket(packet) {
	        const sameNamespace = packet.nsp === this.nsp;
	        if (!sameNamespace)
	            return;
	        switch (packet.type) {
	            case PacketType.CONNECT:
	                if (packet.data && packet.data.sid) {
	                    this.onconnect(packet.data.sid, packet.data.pid);
	                }
	                else {
	                    this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
	                }
	                break;
	            case PacketType.EVENT:
	            case PacketType.BINARY_EVENT:
	                this.onevent(packet);
	                break;
	            case PacketType.ACK:
	            case PacketType.BINARY_ACK:
	                this.onack(packet);
	                break;
	            case PacketType.DISCONNECT:
	                this.ondisconnect();
	                break;
	            case PacketType.CONNECT_ERROR:
	                this.destroy();
	                const err = new Error(packet.data.message);
	                // @ts-ignore
	                err.data = packet.data.data;
	                this.emitReserved("connect_error", err);
	                break;
	        }
	    }
	    /**
	     * Called upon a server event.
	     *
	     * @param packet
	     * @private
	     */
	    onevent(packet) {
	        const args = packet.data || [];
	        if (null != packet.id) {
	            args.push(this.ack(packet.id));
	        }
	        if (this.connected) {
	            this.emitEvent(args);
	        }
	        else {
	            this.receiveBuffer.push(Object.freeze(args));
	        }
	    }
	    emitEvent(args) {
	        if (this._anyListeners && this._anyListeners.length) {
	            const listeners = this._anyListeners.slice();
	            for (const listener of listeners) {
	                listener.apply(this, args);
	            }
	        }
	        super.emit.apply(this, args);
	        if (this._pid && args.length && typeof args[args.length - 1] === "string") {
	            this._lastOffset = args[args.length - 1];
	        }
	    }
	    /**
	     * Produces an ack callback to emit with an event.
	     *
	     * @private
	     */
	    ack(id) {
	        const self = this;
	        let sent = false;
	        return function (...args) {
	            // prevent double callbacks
	            if (sent)
	                return;
	            sent = true;
	            self.packet({
	                type: PacketType.ACK,
	                id: id,
	                data: args,
	            });
	        };
	    }
	    /**
	     * Called upon a server acknowledgement.
	     *
	     * @param packet
	     * @private
	     */
	    onack(packet) {
	        const ack = this.acks[packet.id];
	        if (typeof ack !== "function") {
	            return;
	        }
	        delete this.acks[packet.id];
	        // @ts-ignore FIXME ack is incorrectly inferred as 'never'
	        if (ack.withError) {
	            packet.data.unshift(null);
	        }
	        // @ts-ignore
	        ack.apply(this, packet.data);
	    }
	    /**
	     * Called upon server connect.
	     *
	     * @private
	     */
	    onconnect(id, pid) {
	        this.id = id;
	        this.recovered = pid && this._pid === pid;
	        this._pid = pid; // defined only if connection state recovery is enabled
	        this.connected = true;
	        this.emitBuffered();
	        this.emitReserved("connect");
	        this._drainQueue(true);
	    }
	    /**
	     * Emit buffered events (received and emitted).
	     *
	     * @private
	     */
	    emitBuffered() {
	        this.receiveBuffer.forEach((args) => this.emitEvent(args));
	        this.receiveBuffer = [];
	        this.sendBuffer.forEach((packet) => {
	            this.notifyOutgoingListeners(packet);
	            this.packet(packet);
	        });
	        this.sendBuffer = [];
	    }
	    /**
	     * Called upon server disconnect.
	     *
	     * @private
	     */
	    ondisconnect() {
	        this.destroy();
	        this.onclose("io server disconnect");
	    }
	    /**
	     * Called upon forced client/server side disconnections,
	     * this method ensures the manager stops tracking us and
	     * that reconnections don't get triggered for this.
	     *
	     * @private
	     */
	    destroy() {
	        if (this.subs) {
	            // clean subscriptions to avoid reconnections
	            this.subs.forEach((subDestroy) => subDestroy());
	            this.subs = undefined;
	        }
	        this.io["_destroy"](this);
	    }
	    /**
	     * Disconnects the socket manually. In that case, the socket will not try to reconnect.
	     *
	     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
	     *
	     * @example
	     * const socket = io();
	     *
	     * socket.on("disconnect", (reason) => {
	     *   // console.log(reason); prints "io client disconnect"
	     * });
	     *
	     * socket.disconnect();
	     *
	     * @return self
	     */
	    disconnect() {
	        if (this.connected) {
	            this.packet({ type: PacketType.DISCONNECT });
	        }
	        // remove socket from pool
	        this.destroy();
	        if (this.connected) {
	            // fire events
	            this.onclose("io client disconnect");
	        }
	        return this;
	    }
	    /**
	     * Alias for {@link disconnect()}.
	     *
	     * @return self
	     */
	    close() {
	        return this.disconnect();
	    }
	    /**
	     * Sets the compress flag.
	     *
	     * @example
	     * socket.compress(false).emit("hello");
	     *
	     * @param compress - if `true`, compresses the sending data
	     * @return self
	     */
	    compress(compress) {
	        this.flags.compress = compress;
	        return this;
	    }
	    /**
	     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
	     * ready to send messages.
	     *
	     * @example
	     * socket.volatile.emit("hello"); // the server may or may not receive it
	     *
	     * @returns self
	     */
	    get volatile() {
	        this.flags.volatile = true;
	        return this;
	    }
	    /**
	     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
	     * given number of milliseconds have elapsed without an acknowledgement from the server:
	     *
	     * @example
	     * socket.timeout(5000).emit("my-event", (err) => {
	     *   if (err) {
	     *     // the server did not acknowledge the event in the given delay
	     *   }
	     * });
	     *
	     * @returns self
	     */
	    timeout(timeout) {
	        this.flags.timeout = timeout;
	        return this;
	    }
	    /**
	     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
	     * callback.
	     *
	     * @example
	     * socket.onAny((event, ...args) => {
	     *   console.log(`got ${event}`);
	     * });
	     *
	     * @param listener
	     */
	    onAny(listener) {
	        this._anyListeners = this._anyListeners || [];
	        this._anyListeners.push(listener);
	        return this;
	    }
	    /**
	     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
	     * callback. The listener is added to the beginning of the listeners array.
	     *
	     * @example
	     * socket.prependAny((event, ...args) => {
	     *   console.log(`got event ${event}`);
	     * });
	     *
	     * @param listener
	     */
	    prependAny(listener) {
	        this._anyListeners = this._anyListeners || [];
	        this._anyListeners.unshift(listener);
	        return this;
	    }
	    /**
	     * Removes the listener that will be fired when any event is emitted.
	     *
	     * @example
	     * const catchAllListener = (event, ...args) => {
	     *   console.log(`got event ${event}`);
	     * }
	     *
	     * socket.onAny(catchAllListener);
	     *
	     * // remove a specific listener
	     * socket.offAny(catchAllListener);
	     *
	     * // or remove all listeners
	     * socket.offAny();
	     *
	     * @param listener
	     */
	    offAny(listener) {
	        if (!this._anyListeners) {
	            return this;
	        }
	        if (listener) {
	            const listeners = this._anyListeners;
	            for (let i = 0; i < listeners.length; i++) {
	                if (listener === listeners[i]) {
	                    listeners.splice(i, 1);
	                    return this;
	                }
	            }
	        }
	        else {
	            this._anyListeners = [];
	        }
	        return this;
	    }
	    /**
	     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
	     * e.g. to remove listeners.
	     */
	    listenersAny() {
	        return this._anyListeners || [];
	    }
	    /**
	     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
	     * callback.
	     *
	     * Note: acknowledgements sent to the server are not included.
	     *
	     * @example
	     * socket.onAnyOutgoing((event, ...args) => {
	     *   console.log(`sent event ${event}`);
	     * });
	     *
	     * @param listener
	     */
	    onAnyOutgoing(listener) {
	        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
	        this._anyOutgoingListeners.push(listener);
	        return this;
	    }
	    /**
	     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
	     * callback. The listener is added to the beginning of the listeners array.
	     *
	     * Note: acknowledgements sent to the server are not included.
	     *
	     * @example
	     * socket.prependAnyOutgoing((event, ...args) => {
	     *   console.log(`sent event ${event}`);
	     * });
	     *
	     * @param listener
	     */
	    prependAnyOutgoing(listener) {
	        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
	        this._anyOutgoingListeners.unshift(listener);
	        return this;
	    }
	    /**
	     * Removes the listener that will be fired when any event is emitted.
	     *
	     * @example
	     * const catchAllListener = (event, ...args) => {
	     *   console.log(`sent event ${event}`);
	     * }
	     *
	     * socket.onAnyOutgoing(catchAllListener);
	     *
	     * // remove a specific listener
	     * socket.offAnyOutgoing(catchAllListener);
	     *
	     * // or remove all listeners
	     * socket.offAnyOutgoing();
	     *
	     * @param [listener] - the catch-all listener (optional)
	     */
	    offAnyOutgoing(listener) {
	        if (!this._anyOutgoingListeners) {
	            return this;
	        }
	        if (listener) {
	            const listeners = this._anyOutgoingListeners;
	            for (let i = 0; i < listeners.length; i++) {
	                if (listener === listeners[i]) {
	                    listeners.splice(i, 1);
	                    return this;
	                }
	            }
	        }
	        else {
	            this._anyOutgoingListeners = [];
	        }
	        return this;
	    }
	    /**
	     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
	     * e.g. to remove listeners.
	     */
	    listenersAnyOutgoing() {
	        return this._anyOutgoingListeners || [];
	    }
	    /**
	     * Notify the listeners for each packet sent
	     *
	     * @param packet
	     *
	     * @private
	     */
	    notifyOutgoingListeners(packet) {
	        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
	            const listeners = this._anyOutgoingListeners.slice();
	            for (const listener of listeners) {
	                listener.apply(this, packet.data);
	            }
	        }
	    }
	}

	/**
	 * Initialize backoff timer with `opts`.
	 *
	 * - `min` initial timeout in milliseconds [100]
	 * - `max` max timeout [10000]
	 * - `jitter` [0]
	 * - `factor` [2]
	 *
	 * @param {Object} opts
	 * @api public
	 */
	function Backoff(opts) {
	    opts = opts || {};
	    this.ms = opts.min || 100;
	    this.max = opts.max || 10000;
	    this.factor = opts.factor || 2;
	    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	    this.attempts = 0;
	}
	/**
	 * Return the backoff duration.
	 *
	 * @return {Number}
	 * @api public
	 */
	Backoff.prototype.duration = function () {
	    var ms = this.ms * Math.pow(this.factor, this.attempts++);
	    if (this.jitter) {
	        var rand = Math.random();
	        var deviation = Math.floor(rand * this.jitter * ms);
	        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
	    }
	    return Math.min(ms, this.max) | 0;
	};
	/**
	 * Reset the number of attempts.
	 *
	 * @api public
	 */
	Backoff.prototype.reset = function () {
	    this.attempts = 0;
	};
	/**
	 * Set the minimum duration
	 *
	 * @api public
	 */
	Backoff.prototype.setMin = function (min) {
	    this.ms = min;
	};
	/**
	 * Set the maximum duration
	 *
	 * @api public
	 */
	Backoff.prototype.setMax = function (max) {
	    this.max = max;
	};
	/**
	 * Set the jitter
	 *
	 * @api public
	 */
	Backoff.prototype.setJitter = function (jitter) {
	    this.jitter = jitter;
	};

	class Manager extends Emitter {
	    constructor(uri, opts) {
	        var _a;
	        super();
	        this.nsps = {};
	        this.subs = [];
	        if (uri && "object" === typeof uri) {
	            opts = uri;
	            uri = undefined;
	        }
	        opts = opts || {};
	        opts.path = opts.path || "/socket.io";
	        this.opts = opts;
	        installTimerFunctions(this, opts);
	        this.reconnection(opts.reconnection !== false);
	        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
	        this.reconnectionDelay(opts.reconnectionDelay || 1000);
	        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
	        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
	        this.backoff = new Backoff({
	            min: this.reconnectionDelay(),
	            max: this.reconnectionDelayMax(),
	            jitter: this.randomizationFactor(),
	        });
	        this.timeout(null == opts.timeout ? 20000 : opts.timeout);
	        this._readyState = "closed";
	        this.uri = uri;
	        const _parser = opts.parser || parser;
	        this.encoder = new _parser.Encoder();
	        this.decoder = new _parser.Decoder();
	        this._autoConnect = opts.autoConnect !== false;
	        if (this._autoConnect)
	            this.open();
	    }
	    reconnection(v) {
	        if (!arguments.length)
	            return this._reconnection;
	        this._reconnection = !!v;
	        if (!v) {
	            this.skipReconnect = true;
	        }
	        return this;
	    }
	    reconnectionAttempts(v) {
	        if (v === undefined)
	            return this._reconnectionAttempts;
	        this._reconnectionAttempts = v;
	        return this;
	    }
	    reconnectionDelay(v) {
	        var _a;
	        if (v === undefined)
	            return this._reconnectionDelay;
	        this._reconnectionDelay = v;
	        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
	        return this;
	    }
	    randomizationFactor(v) {
	        var _a;
	        if (v === undefined)
	            return this._randomizationFactor;
	        this._randomizationFactor = v;
	        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
	        return this;
	    }
	    reconnectionDelayMax(v) {
	        var _a;
	        if (v === undefined)
	            return this._reconnectionDelayMax;
	        this._reconnectionDelayMax = v;
	        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
	        return this;
	    }
	    timeout(v) {
	        if (!arguments.length)
	            return this._timeout;
	        this._timeout = v;
	        return this;
	    }
	    /**
	     * Starts trying to reconnect if reconnection is enabled and we have not
	     * started reconnecting yet
	     *
	     * @private
	     */
	    maybeReconnectOnOpen() {
	        // Only try to reconnect if it's the first time we're connecting
	        if (!this._reconnecting &&
	            this._reconnection &&
	            this.backoff.attempts === 0) {
	            // keeps reconnection from firing twice for the same reconnection loop
	            this.reconnect();
	        }
	    }
	    /**
	     * Sets the current transport `socket`.
	     *
	     * @param {Function} fn - optional, callback
	     * @return self
	     * @public
	     */
	    open(fn) {
	        if (~this._readyState.indexOf("open"))
	            return this;
	        this.engine = new Socket$1(this.uri, this.opts);
	        const socket = this.engine;
	        const self = this;
	        this._readyState = "opening";
	        this.skipReconnect = false;
	        // emit `open`
	        const openSubDestroy = on(socket, "open", function () {
	            self.onopen();
	            fn && fn();
	        });
	        const onError = (err) => {
	            this.cleanup();
	            this._readyState = "closed";
	            this.emitReserved("error", err);
	            if (fn) {
	                fn(err);
	            }
	            else {
	                // Only do this if there is no fn to handle the error
	                this.maybeReconnectOnOpen();
	            }
	        };
	        // emit `error`
	        const errorSub = on(socket, "error", onError);
	        if (false !== this._timeout) {
	            const timeout = this._timeout;
	            // set timer
	            const timer = this.setTimeoutFn(() => {
	                openSubDestroy();
	                onError(new Error("timeout"));
	                socket.close();
	            }, timeout);
	            if (this.opts.autoUnref) {
	                timer.unref();
	            }
	            this.subs.push(() => {
	                this.clearTimeoutFn(timer);
	            });
	        }
	        this.subs.push(openSubDestroy);
	        this.subs.push(errorSub);
	        return this;
	    }
	    /**
	     * Alias for open()
	     *
	     * @return self
	     * @public
	     */
	    connect(fn) {
	        return this.open(fn);
	    }
	    /**
	     * Called upon transport open.
	     *
	     * @private
	     */
	    onopen() {
	        // clear old subs
	        this.cleanup();
	        // mark as open
	        this._readyState = "open";
	        this.emitReserved("open");
	        // add new subs
	        const socket = this.engine;
	        this.subs.push(on(socket, "ping", this.onping.bind(this)), on(socket, "data", this.ondata.bind(this)), on(socket, "error", this.onerror.bind(this)), on(socket, "close", this.onclose.bind(this)), 
	        // @ts-ignore
	        on(this.decoder, "decoded", this.ondecoded.bind(this)));
	    }
	    /**
	     * Called upon a ping.
	     *
	     * @private
	     */
	    onping() {
	        this.emitReserved("ping");
	    }
	    /**
	     * Called with data.
	     *
	     * @private
	     */
	    ondata(data) {
	        try {
	            this.decoder.add(data);
	        }
	        catch (e) {
	            this.onclose("parse error", e);
	        }
	    }
	    /**
	     * Called when parser fully decodes a packet.
	     *
	     * @private
	     */
	    ondecoded(packet) {
	        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a "parse error"
	        nextTick(() => {
	            this.emitReserved("packet", packet);
	        }, this.setTimeoutFn);
	    }
	    /**
	     * Called upon socket error.
	     *
	     * @private
	     */
	    onerror(err) {
	        this.emitReserved("error", err);
	    }
	    /**
	     * Creates a new socket for the given `nsp`.
	     *
	     * @return {Socket}
	     * @public
	     */
	    socket(nsp, opts) {
	        let socket = this.nsps[nsp];
	        if (!socket) {
	            socket = new Socket(this, nsp, opts);
	            this.nsps[nsp] = socket;
	        }
	        else if (this._autoConnect && !socket.active) {
	            socket.connect();
	        }
	        return socket;
	    }
	    /**
	     * Called upon a socket close.
	     *
	     * @param socket
	     * @private
	     */
	    _destroy(socket) {
	        const nsps = Object.keys(this.nsps);
	        for (const nsp of nsps) {
	            const socket = this.nsps[nsp];
	            if (socket.active) {
	                return;
	            }
	        }
	        this._close();
	    }
	    /**
	     * Writes a packet.
	     *
	     * @param packet
	     * @private
	     */
	    _packet(packet) {
	        const encodedPackets = this.encoder.encode(packet);
	        for (let i = 0; i < encodedPackets.length; i++) {
	            this.engine.write(encodedPackets[i], packet.options);
	        }
	    }
	    /**
	     * Clean up transport subscriptions and packet buffer.
	     *
	     * @private
	     */
	    cleanup() {
	        this.subs.forEach((subDestroy) => subDestroy());
	        this.subs.length = 0;
	        this.decoder.destroy();
	    }
	    /**
	     * Close the current socket.
	     *
	     * @private
	     */
	    _close() {
	        this.skipReconnect = true;
	        this._reconnecting = false;
	        this.onclose("forced close");
	    }
	    /**
	     * Alias for close()
	     *
	     * @private
	     */
	    disconnect() {
	        return this._close();
	    }
	    /**
	     * Called when:
	     *
	     * - the low-level engine is closed
	     * - the parser encountered a badly formatted packet
	     * - all sockets are disconnected
	     *
	     * @private
	     */
	    onclose(reason, description) {
	        var _a;
	        this.cleanup();
	        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
	        this.backoff.reset();
	        this._readyState = "closed";
	        this.emitReserved("close", reason, description);
	        if (this._reconnection && !this.skipReconnect) {
	            this.reconnect();
	        }
	    }
	    /**
	     * Attempt a reconnection.
	     *
	     * @private
	     */
	    reconnect() {
	        if (this._reconnecting || this.skipReconnect)
	            return this;
	        const self = this;
	        if (this.backoff.attempts >= this._reconnectionAttempts) {
	            this.backoff.reset();
	            this.emitReserved("reconnect_failed");
	            this._reconnecting = false;
	        }
	        else {
	            const delay = this.backoff.duration();
	            this._reconnecting = true;
	            const timer = this.setTimeoutFn(() => {
	                if (self.skipReconnect)
	                    return;
	                this.emitReserved("reconnect_attempt", self.backoff.attempts);
	                // check again for the case socket closed in above events
	                if (self.skipReconnect)
	                    return;
	                self.open((err) => {
	                    if (err) {
	                        self._reconnecting = false;
	                        self.reconnect();
	                        this.emitReserved("reconnect_error", err);
	                    }
	                    else {
	                        self.onreconnect();
	                    }
	                });
	            }, delay);
	            if (this.opts.autoUnref) {
	                timer.unref();
	            }
	            this.subs.push(() => {
	                this.clearTimeoutFn(timer);
	            });
	        }
	    }
	    /**
	     * Called upon successful reconnect.
	     *
	     * @private
	     */
	    onreconnect() {
	        const attempt = this.backoff.attempts;
	        this._reconnecting = false;
	        this.backoff.reset();
	        this.emitReserved("reconnect", attempt);
	    }
	}

	/**
	 * Managers cache.
	 */
	const cache = {};
	function lookup(uri, opts) {
	    if (typeof uri === "object") {
	        opts = uri;
	        uri = undefined;
	    }
	    opts = opts || {};
	    const parsed = url(uri, opts.path || "/socket.io");
	    const source = parsed.source;
	    const id = parsed.id;
	    const path = parsed.path;
	    const sameNamespace = cache[id] && path in cache[id]["nsps"];
	    const newConnection = opts.forceNew ||
	        opts["force new connection"] ||
	        false === opts.multiplex ||
	        sameNamespace;
	    let io;
	    if (newConnection) {
	        io = new Manager(source, opts);
	    }
	    else {
	        if (!cache[id]) {
	            cache[id] = new Manager(source, opts);
	        }
	        io = cache[id];
	    }
	    if (parsed.query && !opts.query) {
	        opts.query = parsed.queryKey;
	    }
	    return io.socket(parsed.path, opts);
	}
	// so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
	// namespace (e.g. `io.connect(...)`), for backward compatibility
	Object.assign(lookup, {
	    Manager,
	    Socket,
	    io: lookup,
	    connect: lookup,
	});

	Bar[FILENAME] = 'src/routes/CSDisplay/Bar.svelte';

	var root$4 = add_locations(from_html(`<div class="card svelte-v5e5gj"><div class="card-header svelte-v5e5gj"><span> </span> <span class="value svelte-v5e5gj"> </span></div> <div class="bar svelte-v5e5gj"><div></div></div></div>`), Bar[FILENAME], [
		[
			5,
			0,
			[
				[6, 2, [[7, 4], [8, 4]]],
				[10, 2, [[11, 4]]]
			]
		]
	]);

	function Bar($$anchor, $$props) {
		check_target(new.target);
		push($$props, true, Bar);

		var div = root$4();
		var div_1 = child(div);
		var span = child(div_1);
		var text = child(span);

		var span_1 = sibling(span, 2);
		var text_1 = child(span_1);

		var div_2 = sibling(div_1, 2);
		var div_3 = child(div_2);
		let styles;

		template_effect(() => {
			set_text(text, $$props.moveName);
			set_text(text_1, `${$$props.koPercent ?? ''}%`);
			set_class(div_3, 1, `bar-fill ${$$props.isActive ? '' : 'inactive'}`, 'svelte-v5e5gj');
			styles = set_style(div_3, '', styles, { width: $$props.width });
		});

		append($$anchor, div);
		return pop({ ...legacy_api() });
	}

	CombatSystemDisplay[FILENAME] = 'src/routes/CSDisplay/CombatSystemDisplay.svelte';

	var on_click = (_, currentPercent) => set(currentPercent, get(currentPercent) + 20);
	var on_click_1 = (__1, currentPercent) => set(currentPercent, 0);

	var root$3 = add_locations(from_html(`<div class="dashboard svelte-b7gfnd"><div class="dev svelte-b7gfnd"><h4>Combat System Display Test</h4> <button>+20%</button> <button>Reset</button></div> <div class="title svelte-b7gfnd"><h3> <span> </span></h3> <h3 class="stage svelte-b7gfnd"> </h3></div> <h1 class="title svelte-b7gfnd">KO Moves</h1> <div class="grid svelte-b7gfnd"></div></div>`), CombatSystemDisplay[FILENAME], [
		[
			166,
			0,
			[
				[
					167,
					2,
					[[168, 4], [170, 4], [171, 4]]
				],
				[
					174,
					2,
					[
						[175, 4, [[176, 42]]],
						[178, 4]
					]
				],
				[183, 2],
				[184, 2]
			]
		]
	]);

	function CombatSystemDisplay($$anchor, $$props) {
		check_target(new.target);
		push($$props, true, CombatSystemDisplay);

		const MY_CONNECT_CODE = "BLAN#461";

		function stageInitialsToName(initials) {
			const stageNames = {
				DL: "Dream Land N64",
				YS: "Yoshi's Story",
				PS: "Pokémon Stadium",
				FD: "Final Destination",
				FoD: "Fountain of Dreams",
				BF: "Battlefield"
			};

			return stageNames[initials] || "Battlefield";
		}

		function isCurrentStage(matchupEntry) {
			const fullStageName = stageInitialsToName(matchupEntry.stage);

			console.log(...log_if_contains_state('log', "testing matchup.stage", matchupEntry.stage));
			console.log(...log_if_contains_state('log', "settings.stageName", settings.stageName));
			return strict_equals(fullStageName, settings.stageName);
		}

		let matchupData = tag(state(void 0), 'matchupData');
		let currentPercent = tag(state(0), 'currentPercent');
		let displayStageName = tag(state("on Earth"), 'displayStageName');
		let red = 255;
		let green = tag(state(void 0), 'green');
		let blue = tag(state(void 0), 'blue');
		let opponentChar = tag(state("Test"), 'opponentChar');
		let opponentPlayerIdx = 1;
		const socket = lookup("http://localhost:8090");

		onMount(() => {
			// Add typing to this 
			socket.on('game_start', async (settings) => {
				// Get Game Info
				set(displayStageName, settings.stageName, true);

				let players = settings.players;

				// If player length is not two show error
				if (equals(players.length, 2, false)) {
					console.error("Player length is not 2");
				}

				// Test Output
				console.log(...log_if_contains_state('log', "players[0].characterShortName", players[0].characterShortName));
				console.log(...log_if_contains_state('log', "players[1].characterShortName", players[1].characterShortName));

				// Get your and opponents index and character based on connect code
				let myPlayerIdx = players.findIndex((p) => strict_equals(p?.connectCode, MY_CONNECT_CODE));

				opponentPlayerIdx = players.findIndex((p) => strict_equals(p?.connectCode, MY_CONNECT_CODE, false));

				const myChar = players[myPlayerIdx]?.characterShortName.toLowerCase();

				set(opponentChar, players[opponentPlayerIdx]?.characterShortName.toLowerCase(), true);
				// Testing...
				console.log(...log_if_contains_state('log', "myPlayerIdx", myPlayerIdx));
				console.log(...log_if_contains_state('log', "opponentPlayerIdx", opponentPlayerIdx));
				console.log(...log_if_contains_state('log', "myPlayer", myPlayer));
				console.log(...log_if_contains_state('log', "opponentPlayer", opponentPlayer));
				console.log(...log_if_contains_state('log', `My connect code: ${myPlayer?.connectCode}`));
				console.log(...log_if_contains_state('log', `Opponent's connect code: ${opponentPlayer?.connectCode}`));

				// Load matchup data
				try {
					const matchupPath = `/data/${myChar}/vs_${get(opponentChar)}.json`;
					const response = await fetch(matchupPath);
					const allStagesKOData = await response.json();

					console.log(...log_if_contains_state('log', "Loaded perspective matchup data:", allStagesKOData));

					const currentStageData = allStagesKOData.find(isCurrentStage);

					console.log(...log_if_contains_state('log', "stageMatchupData", currentStageData));
					set(matchupData, currentStageData, true);
				} catch(e) {
					console.error(...log_if_contains_state('error', "Could not load matchup data for", matchupPath, e));
					set(matchupData, null);
				}
			});

			socket.on('slippi_update', (players) => {
				console.log(...log_if_contains_state('log', "WHOA received an event with info ", JSON.stringify(players)));

				if (players && players[opponentPlayerIdx] && strict_equals(typeof players[opponentPlayerIdx].percent, 'number')) {
					set(currentPercent, players[opponentPlayerIdx].percent, true);
					console.log(...log_if_contains_state('log', "UPDATED currentPercent:", get(currentPercent)));
				} else {
					console.log("No valid data received");
				}
			});

			return () => socket.disconnect();
		});

		const sampleDynamicData = {
			"fileDone?": false,
			"attacker": "Fox",
			"defender": "Marth",
			"stage": "YS",
			"moves": {
				"upSmash": 83.0,
				"strongUpTilt": 102.0,
				"downTilt": 145.0,
				"bAir": 124.0,
				"shuAir": 105.0
			}
		};

		const isHighlighted = (val) => strict_equals(typeof get(currentPercent), 'number') && get(currentPercent) >= val;

		// Compute how red text should look based on percent 
		run(() => {
			set(green, 255 - Math.round(get(currentPercent) / 150 * 255));
		});

		run(() => {
			set(blue, 255 - Math.round(get(currentPercent) / 150 * 255));
		});

		let percent_color = tag(user_derived(() => `rgb(${red},${get(green)},${get(blue)})`), 'percent_color');

		let dynamicBars = tag(
			user_derived(() => Object.entries(get(matchupData)?.moves || sampleDynamicData.moves).map(([moveName, koPercent]) => {
				//Need to sort by stage
				const highlighted = isHighlighted(koPercent);

				return {
					moveName,
					koPercent,
					width: koPercent ? `${Math.min(100, get(currentPercent) / koPercent * 100).toFixed(1)}%` : '0%',
					class: highlighted ? 'bar-fill' : 'bar-fill inactive'
				};
			})),
			'dynamicBars'
		);

		console.log(...log_if_contains_state('log', "dynamicBars", get(dynamicBars)));

		var div = root$3();
		var div_1 = child(div);
		var button = sibling(child(div_1), 2);

		button.__click = [on_click, currentPercent];

		var button_1 = sibling(button, 2);

		button_1.__click = [on_click_1, currentPercent];

		var div_2 = sibling(div_1, 2);
		var h3 = child(div_2);
		var text = child(h3);
		var span = sibling(text);
		var text_1 = child(span);

		var h3_1 = sibling(h3, 2);
		var text_2 = child(h3_1);

		var div_3 = sibling(div_2, 4);

		each(div_3, 21, () => get(dynamicBars), index, ($$anchor, bar) => {
			Bar($$anchor, spread_props(() => get(bar)));
		});

		template_effect(() => {
			set_text(text, `${get(opponentChar) ?? ''}'s current percent is `);
			set_style(span, `color: ${get(percent_color) ?? ''};`);
			set_text(text_1, `${get(currentPercent) ?? ''}%`);
			set_text(text_2, get(displayStageName).length > 0 ? `${get(displayStageName)}` : ``);
		});

		append($$anchor, div);
		return pop({ ...legacy_api() });
	}

	delegate(['click']);

	Logo[FILENAME] = 'src/Logo.svelte';

	var root$2 = add_locations(from_html(`<a id="zko" class="svelte-xqgr9a">ZK<span class="svelte-xqgr9a">O_2</span>0XX</a>`), Logo[FILENAME], [[17, 0, [[17, 14]]]]);

	function Logo($$anchor, $$props) {
		check_target(new.target);
		push($$props, false, Logo);

		var a = root$2();

		append($$anchor, a);
		return pop({ ...legacy_api() });
	}

	Navbar[FILENAME] = 'src/Navbar.svelte';

	var root$1 = add_locations(from_html(`<nav class="svelte-9v3ask"><ul class="svelte-9v3ask"><li class="svelte-9v3ask"><a class="svelte-9v3ask"><!></a></li>  <li class="svelte-9v3ask"><a class="svelte-9v3ask">Dark Mode</a></li> <li class="svelte-9v3ask"><a class="svelte-9v3ask">Settings</a></li></ul></nav>`), Navbar[FILENAME], [
		[
			42,
			0,
			[
				[
					43,
					2,
					[
						[44, 4, [[44, 8]]],
						[47, 4, [[48, 6]]],
						[50, 4, [[51, 6]]]
					]
				]
			]
		]
	]);

	function Navbar($$anchor, $$props) {
		check_target(new.target);
		push($$props, false, Navbar);

		var nav = root$1();
		var ul = child(nav);
		var li = child(ul);
		var a = child(li);
		var node = child(a);

		Logo(node, {});
		append($$anchor, nav);
		return pop({ ...legacy_api() });
	}

	App[FILENAME] = 'src/App.svelte';

	var root = add_locations(from_html(`<main class="svelte-eu18ws"><!></main> <!> <!>`, 1), App[FILENAME], [[7, 0]]);

	function App($$anchor, $$props) {
		check_target(new.target);
		push($$props, false, App);
		var fragment = root();
		var main = first_child(fragment);
		var node = child(main);

		Navbar(node, {});

		var node_1 = sibling(main, 2);

		CombatSystemDisplay(node_1, {});

		var node_2 = sibling(node_1, 2);

		{

			if_block(node_2, ($$render) => {
			});
		}

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	const app = mount(App, {
	    target: document.body,
	    props: {
	        name: 'melee'
	    }
	});

	return app;

})();
//# sourceMappingURL=bundle.js.map
